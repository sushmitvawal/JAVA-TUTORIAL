THE JAVA PLATFORM-
	Java platform has 2 components.
	1. JVM (used to achieve platform independence)
	2. JAVA Application Programming Interface (API) -(Bunch of librabies and methods that we use)

	Used to run languages that are not JAVA eg.Groovy, Scala etc are not JAVA but have been written for the JAVA platform
	The java compiler compiles your source code to an intermediate language (byte code) that is interpreted by the JVM
	byte code is NOT machine code that gets executed directly. Instead the JVM translates the byte code to machine code, which gets run by the actual platform.
	byte code is platform independent
	JAVA APPLICATION --> JAVA COMPILER --> BYTE CODE --> JVM --> MACHINE CODE --> HANDWARE/OS

	What components makes up the Java Runtime Environment (JRE)?
	Ans:
	1. JVM
	2. JAVA Application Programming Interface (API) 
	
	True or False: The JVM is able to run languages other than Java?
	Ans: True

EDITIONS OF JAVA:
	1. JAVA EE(ENTERPRISE) (build distributed applications. eg using web features in our applications)
	2. JAVA SE(STANDARD) (basic codiing)
	3. JAVA ME(MICRO)(Used in IOT eg code for automatic fans)
	JAVA EE  is a superset of JAVA SE and JAVA SE is superset of JAVA ME
	JAVA EE --> JAVA SE --> JAVA ME

MAIN METHOD:
	public static void main(String[] args) can also be written as  static public void main(String[] args)
	the order doesn't matter as long as it is to the left of returntype	 
	It must return "void."
	The name "main" must be written in all lowercase
	It must declare a String array parameter (where the square brackets may be written to the right of String or to the right of the identifier).
	The identifier for the String array may be named anything you'd like (though, by convention, it is typically "args").
	
	Is this correct?
	static public void main(String command_Line_Arguments[])
	Ans: YES

COMPILING CODE:
	Using javac filename.java will create a filname.class file which is the byte code(binary). Then "java filename" cmd will run the .class file and give an output. 


CLASS-
	A class is a user defined blueprint or prototype from which objects are created.
	It represents the set of properties or methods that are common to all objects of one type

WHY OVERRIDE METHODS IN POJO:
	When you're creating simple Java classes (POJOs), it's a good idea to override a few special methods:
	1. `equals()`: Decide how two objects of your class should be considered equal.
	2. `hashCode()`: Create a unique number for each object, important for certain data structures.
	3. `toString()`: Provide a nice human-readable description of your object.
	These overrides help your classes work better with collections, comparisons, and debugging.

What is a POJO class?
   Answer: A POJO (Plain Old Java Object) class is a Java class that adheres to basic Java principles without relying on any specific frameworks or libraries. It typically has private fields, public getters and setters, and may optionally override certain methods for better functionality.

Why would you use a POJO class?
   Answer: POJOs are used to keep the code simple and maintainable. They help encapsulate data and behavior within objects, making it easier to manage and understand the code. POJOs are also useful for data transfer between layers of an application or when interacting with external systems.

What are the key requirements for a class to be considered a POJO?
   Answer: The key requirements for a class to be considered a POJO are:
   - The class should have private fields.
   - It should provide public getter and setter methods for each field (if needed).
   - It may optionally override methods like `equals`, `hashCode`, and `toString`.

Why is it important to override the `equals`, `hashCode`, and `toString` methods in a POJO class?
   Answer: These methods affect how instances of a class behave in various contexts: 
   - `equals`: Determines object equality.
   - `hashCode`: Ensures consistent behavior in hash-based collections.
   - `toString`: Provides a human-readable representation of the object.

What is the purpose of the `toString` method in a POJO class?**
   Answer: The `toString` method provides a user-friendly representation of the object's state. It's useful for debugging, logging, and generating informative output.

Can you give an example of a situation where you might use a POJO class?**
    Answer: You might use a POJO class to represent a `Person` entity in a database, with fields like name, age, and address, along with getters, setters, and potentially overridden methods.

Apart from `equals`, `hashCode`, and `toString`, are there any other methods you might consider overriding in a POJO class?**
    Answer: Depending on the situation, you might consider overriding `compareTo` for implementing the `Comparable` interface if you need to compare instances of the class.

What is the role of JavaBeans conventions in POJOs?**
    Answer: JavaBeans conventions provide guidelines for creating reusable components by adhering to naming and design patterns. POJOs often follow these conventions, which promote consistent and maintainable code.

Can a POJO class extend another class or implement interfaces?**
    Answer:** Yes, a POJO class can extend another class and implement interfaces. However, you should ensure that the class remains simple and doesn't become tightly coupled with complex inheritance hierarchies.

OBJECTS-
	An Object is an instance of a Class.
	When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created)
	Memory is allocated.

CONSTRUCTOR-
	Constructor is a block of code that initializes the newly created object.
	It is special type of method which has same name as the class name.
	It does not have a return type.
	There are four types of constructors: Default, No-arg constructor, Parameterized and Copy.

	If you do not implement any constructor in your class, 
	Java compiler inserts a default constructor into your code on your behalf.
	This constructor is known as default constructor. 
	If you implement any constructor then you no longer receive a default constructor from Java compiler.

	Constructor with no arguments is known as no-arg constructor.
	The signature is same as default constructor, 
	however body can have any code unlike default constructor where the body of the constructor is empty.

	Constructor with arguments(or you can say parameters) is known as Parameterized constructor.
	If you create a parameterized cons and if you want to create a obj without parameters then it will
	throw and error. You should have a no-arg cons for that.
	
	A copy constructor is used for copying the values of one object to another object.


SUPER-
	Whenever a child class constructor gets invoked it implicitly invokes the constructor of parent class. 
	You can also say that the compiler inserts a super(); 
	statement at the beginning of child class constructor.
	It can be used to only inside child class constructor.
	Super keyword can be used to invoke parent class variable, method, constructor.
	we cannot use both this and super keyword together in java constructor because this and super should be the first statement in any java constructor.

THIS-
	It is used to access current class constructor.
	It can be used inside another constructor of same class.
	It can be used to remove ambiguity error when we have data members and local are same name.



CONS OVERLOADING-
	Constructor overloading is a concept of having more than one constructor with different parameters list,
	in such a way so that each constructor performs a different task.
	Eg-  no-arg cons and arg 

PRIVATE CONSTRUCTOR-
	The use of private constructor is to serve singleton classes. 
	A singleton class is one which limits the number of objects creation to one. 
	Using private constructor we can ensure that no more than one object can be created at a time. 

STATIC CONSTRUCTOR-
	Not allowed in Java.
Static variable /methods(cons is kind of a method) are associated with class and not the obj where as constructor is basically used to initialize the obj.


QUICK RECAP

Every class has a constructor whether it’s a normal class or an abstract class.

Constructors are not methods and they don’t have any return type.

Constructor can use any access specifier, 
they can be declared as private also. 
Private constructors are possible in java but there scope is within the class only.

Like constructors method can also have name same as class name, 
but still they have return type, though which we can identify them that they are methods not constructors.

this() and super() should be the first statement in the constructor code.
Constructor overloading is possible but overriding is not possible. 
Which means we can have overloaded constructor in our class but we can’t override a constructor.
Constructors can not be inherited.

Interfaces do not have constructors.

Abstract class can have constructor and it gets invoked when a class, 
which implements interface, is instantiated. (i.e. object creation of concrete class).

A constructor can also invoke another constructor of the same class – By using this(). 
If you want to invoke a parameterized constructor then do it like this: this(parameter list).	

STATIC-
	The static keyword belongs to the class than an instance of the class.
	We can apply static keyword with variables, methods, blocks and nested classes.
	We use static keyword in java so that we can save our memory and make memory efficient.
	We can't call non-static data member in static member in java.
	We cannot use this and super in static context,  because this and super belongs to objects.
	because this and super belongs to objects.
	We can define static variable in abstract class.


STATIC VARIABLE-
	The static variable can be used to refer to the common property of all objects 
	(which is not unique for each object),
	for example, IFSC CODE, BANK NAME.
	The static variable gets memory only once in the class area at the time of class loading.

STATIC METHOD-
	A static method belongs to the class rather than the object of a class.
	No obj creation.Can be accessed using class name.
	A static method can access static data member and can change the value of it.
	Static method can be overloaded but cannot override
	Interface can have static methods	
	we can call super class static method in sub class but it can't override in sub class.

	There are two main restrictions for the static method.

	The static method can not use non static data member or call non-static method directly.
	
	class A{  
 	int a=40;//non static  
   
 	public static void main(String args[]){  
  	System.out.println(a);  
 	}  
	}  
	
	this and super cannot be used in static context.

	Why is the Java main method static?
	Ans) It is because the object is not required to call a static method. If it were a non-static method, 
	JVM creates an object first then call main() method that will lead the problem of extra memory allocation.
	Static methods cannot be overridden in Java, but if you declare the same static method in subclass then that would hide the method from its superclass. 
	So, if you call that method from subclass then the one in the subclass will get invoked
	 but if you call the same method from superclass then the one in superclass will be invoked. 
	This is known as method hiding in Java.

STATIC BLOCK-
	Is used to initialize the static data member.
	It is executed before the main method at the time of classloading.
	We can have Multiple static block in the code.

STATIC CLASS-
	A class can be made static only if it is a nested class.

	Nested static class doesn’t need reference of Outer class
	A static class cannot access non-static members of the Outer class

STATIC CONSTRUCTOR-
	Not possible.


INHERITANCE-
	The process by which one class acquires the properties(data members) and functionalities(methods) of another class is called inheritance. 
	The aim of inheritance is to provide the reusability of code 
	so that a class has to write only the unique features and rest of the common properties can be extended from the another class.
	Parent class cannot access the child class members.

	When we declare the same method in child class which is already present in the parent class then this is called method overriding. 
	In this case when we call the method from child class object, the child class version of the method is called. 
	However we can call the parent class method using super keyword.
	The extends always precedes the implements keyword in any Java class declaration.
	
	Single Inheritance: refers to a child and parent class relationship where a class extends the another class.

	Multilevel inheritance: refers to a child and parent class relationship where a class extends the child class. 
	For example class C extends class B and class B extends class A.

	Hierarchical inheritance: refers to a child and parent class relationship where more than one classes extends the same class. 
	For example, classes B, C & D extends the same class A.
	
	Multiple Inheritance: refers to the concept of one class extending more than one classes, which means a child class has two parent classes. 
	For example class C extends both classes A and B. 
	Java doesn’t support multiple inheritance.

	Hybrid inheritance: Combination of more than one types of inheritance in a single program. 
	For example class A & B extends class C and another class D extends class A 
	then this is a hybrid inheritance example because it is a combination of single and hierarchical inheritance. 
Since multiple inheritance is not possible in java, Hybrid is also not possible.

POLYMORPHISM-
	Single task can be done in different way.
	"one name many forms"

	Compile time polymorphism:
	it is nothing but the method overloading in java. 
	In simple terms we can say that a class can have more than one methods with same name but with different number of arguments
	or different types of arguments or both.
	
	Runtime polymorphism:
	Runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time.

METHOD OVERLOADING-
	Method Overloading is a feature that allows a class to have more than one method having the same name, 
	if their argument lists are different.
	Used to update the features of the parent class.

	Method Signature:
	a) Method name

	b) Number of arguments

	c) Types of arguments

	Overloaded methods can be either static or non static
.
	Overloaded methods can be synchronized.

	we can overload main() method. 
	A class can have any number of main() methods 
	but execution starts from public static void main(String[] args) only.
	
	we can declare overloaded methods as final.

	Overloading is the best example for static binding.
	
	we can override a method which is overloaded in super class.
	
METHOD OVERRIDDING-
	Method overriding is another way to define method with same name but different code but it must be in sub class.
	
	Modifying a super class method in the sub class is called method overriding. Using method overriding, 
	we can change super class method according to the requirements of sub class.
	
	Used to update the features of the parent class.
	
	Private methods cannot be overridden as it is not visible outside of the class.
	Static method cannot be overridden
	Constructors cannot be overridden
	You must not reduce the visibility of a method while overriding.
	You can’t override non-static methods as static.

ABSTRACTION-
	To show functionality and hide complexity or internal details or hide implementation details to the user is known as abstraction in java.
	
	There are two ways in java we can achieve abstraction:

	By using abstract class (0 to 100%).
	By using interface (100%).
	 

ABSTRACT METHOD-

	An abstract method is a method without body. You just declare method, without defining it and use abstract keyword in method declaration
		
Abstract class may or may not have abstract methods. can declare and define static methods.
No obj creation of abstract class. To access the non-abstract method of an abstract class, use child class obj.
	Cannot be private
	Cannot be static.
	Cannot be final.
	Abstract classes can be nested.
	abstract methods can not be declared as synchronized.
	abstract class can declare and define a constructor in Java.

	ABSTRACT CLASS VS INTERFACE

	Main difference is methods of a Java interface are implicitly abstract and cannot have implementations. 
	A Java abstract class can have instance methods that implements a default behavior.

	Variables declared in a Java interface is by default final. An  abstract class may contain non-final variables.

	Members of a Java interface are public by default. 
	A Java abstract class can have the usual flavors of class members like private, protected, etc..
	
	Java interface should be implemented using keyword “implements”; A Java abstract class should be extended using keyword “extends”.

	In comparison with java abstract classes, java interfaces are slow as it requires extra indirection.



ENCAPSULATION-
	Binding the data into a single unit.
	Encapsulation is an object oriented concept which is used to hide the internal details of a class.
	In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class.
	
	To achieve encapsulation in Java −

	Declare the variables of a class as private.

	Provide public setter and getter methods to modify and view the variables values.

	Abstraction solves the problem at design level while encapsulation solves the problem at implementation level.	

INTERFACE-
	Yes, unlike classes, an interface can extend more than one interface in Java. 
	There are several example of this behavior in JDK itself
	e.g. java.util.List interface extends both Collection and Iterable interface to tell that it is a Collection as well as it allows iteration via Iterator.
	
FINAL-
	In Java, all non-static methods are by default virtual functions. 
	Methods that are marked with the keyword final are non-virtual.

String-  
	String is a class and not a primitive data type.
	Immutable and final.
	JVM uses string pool to store all string objects.
String class does not have an inbuilt string function to reverse.
	StringBuilder, StringBuffer has reverse() method (to check palindrome).
	String a=new String(“abc”);
	String a=”abc”;
	When we use new operator, JVM creates the string obj but don’t store it into the string pool 
But we can use intern() method to store the obj into string pool or return reference if there is already a string with equal value present in the pool.
Strings are immutable, so we can’t change it’s value in program. Hence it’s thread-safe and can be safely used in multi-threaded environment.
METHOD THAT WILL REMOVE GIVEN CHAR FROM STRING.
We can use replaceAll method to replace all the occurance of a String with another String. The important point to note is that it accepts String as argument, so we will use Character class to create String and use it to replace all the characters with empty String.

private static String removeChar(String str, char c) 
{ 
if (str == null) 
return null; 
return str.replaceAll(Character.toString(c), ""); 
}

We can use String class toUpperCase and toLowerCase methods to get the String in all upper case or lower case.



Java String subSequence
Java 1.4 introduced the CharSequence interface and String implements this interface. This is the only reason for the implementation of subSequence() method in String class. Internally it invokes the substring() method.

public CharSequence subSequence(int beginIndex, int endIndex) { return this.substring(beginIndex, endIndex); }



Java String implements Comparable interface and it has two variants of compareTo() methods.
compareTo(String anotherString) method compares the String object with the String argument passed lexicographically. If String object precedes the argument passed, it returns negative integer and if String object follows the argument String passed, it returns a positive integer. It returns zero when both the String have the same value, in this case equals(String str) method will also return true.
compareToIgnoreCase(String str): This method is similar to the first one, except that it ignores the case. It uses String CASE_INSENSITIVE_ORDER Comparator for case insensitive comparison. If the value is zero then equalsIgnoreCase(String str) will also return true.
We can use String getBytes() method to convert String to byte array and we can use String constructor new String(byte[] arr) to convert byte array to String.
Can we use String in switch case?
This is a tricky question used to check your knowledge of current Java developments. Java 7 extended the capability of switch case to use Strings also, earlier Java versions don’t support this.
If you are implementing conditional flow for Strings, you can use if-else conditions and you can use switch case if you are using Java 7 or higher versions.
	

We can use split(String regex) to split the String into String array based on the provided regular expression

There are two ways to check if two Strings are equal or not – using “==” operator or using equals method. When we use “==” operator, it checks for the value of String as well as the reference but in our programming, most of the time we are checking equality of String for value only. So we should use the equals method to check if two Strings are equal or not.


	
COLLECTION FRAMEWORK-
	

The Collection in Java is a framework that provides an architecture to store and manipulate the group of objects.

Java Collections can achieve all the operations that you perform on a data such as searching, sorting, insertion, manipulation, and deletion.

	Java Collection means a single unit of objects. 
	Java Collection framework provides many interfaces (Set, List, Queue, Deque) 
	and classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet).	


	
	What are the two ways to iterate the elements of a collection?
	ANS- ITERATOR INTERFACE,FOREACH LLOP,LISTITERATOR INTERFACE,FORLOOP.


	What is the difference between ArrayList and LinkedList classes in collection framework?
	ANS 		ARRAY LIST			LINKED LIST
		INTERNALLY USES DYNAMIC ARR	INTERNALLY USES DOUBLY LINKEDLIST
		
		MANIPULATION IS SLOW		MANIPULATON IS FAST
	
		CAN ACT AS A LIST		CAN ACT AS LIST AND QUEUE
						AS IT IMPLEMENTS LIST AND DEQUEUE INTERFACE

		BETTER FOR STORING DATA		BETTER FOR MANIPULATING DATA

	
	What is the difference between ArrayList and Vector classes in collection framework?

			ARRAY LIST					VECTOR

		NOT SYNCRONIZED					SYNCRONIZED
		
		Increments 50% of current			increments 100% of current
		size if total no of elements exceeds		ie doubles arraysize if total no of
		from its capacity				elements exceeds the capacity

		Not legacy class(introduced in JDK1.2)		It is a legacy class

		Fast(Not syncronized)				Slow(Syncronized)

		Uses Iterator interface to traverse		Uses Iterator or Enumeration interface to traverse


	What is the difference between HashSet and HashMap classes in collection framework?

			HASH SET					HASH MAP

		Implements Set Interface			Implements Map interface

		store objects(elements or values)		storing key & value pairs.

		HashSet does not allow duplicate elements	HashMap does not allow duplicate keys 
								however it allows to have duplicate values

permits to have a single null value.		 permits single null key and any   number of null values.


	What is the difference between HashMap and Hashtable class?

	

		
What is the difference between Iterator and Enumeration interface in collection framework?
	
	

How can we sort the elements of an object? What is the difference between Comparable and Comparator interfaces?
ANS- public void sort(List list)
	

What is the difference between Java collection and Java collections?

	
		
	


MULTITHREADING-
Multithreading in Java is a process of executing multiple threads simultaneously.
A thread is a lightweight sub-process, the smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.
However, we use multithreading than multiprocessing because threads use a shared memory area. They don't allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.
    Java Multithreading is mostly used in games, animation, etc.	

Multitasking
Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved in two ways:
oProcess-based Multitasking (Multiprocessing)
oThread-based Multitasking (Multithreading)
1) Process-based Multitasking (Multiprocessing)
oEach process has an address in memory. In other words, each process allocates a separate memory area.
oA process is heavyweight.
oCost of communication between the process is high.
oSwitching from one process to another requires some time for saving and loading registers, memory maps, updating lists, etc.
2) Thread-based Multitasking (Multithreading)
oThreads share the same address space.
oA thread is lightweight.
oCost of communication between the thread is low.
What is Thread in java
A thread is a lightweight subprocess, the smallest unit of processing. It is a separate path of execution.
Threads are independent. If there occurs exception in one thread, it doesn't affect other threads. It uses a shared memory area.
NOTE: At a time one thread is executed only.
Thread class extends Object class and implements Runnable interface.

oHow to perform multithreading by anonymous class?
opublic class AnonymousThreadTest {
o   public static void main(String[] args) {
o      new Thread() {
o         public void run() {
o            for (int i=1; i <= 5; i++) {
o               System.out.println("run() method: " + i);
o            }
o         }
o      }.start();
o      for (int j=1; j <= 5; j++) {
o         System.out.println("main() method: " + j);
o      }
o   }
o}

oWhat happens if we start a thread twice?
After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown. In such case, thread will run once but for second time, it will throw exception.

o	What happens if we call the run() method instead of start() method?
Can we call run() method directly to start a new thread. No, you can not directly call run method to start a thread. You need to call start method to create a new thread. If you call run method directly , it won't create a new thread and it will be in same stack as main
oWhat is the purpose of join method?
The join() method waits for a thread to die. In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task.

oWhat is the shutdown hook?
Shutdown Hooks are a special construct that allows developers to plug in a piece of code to be executed when the JVM is shutting down.


Life cycle of a Thread (Thread States)
A thread can be in one of the five states. According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state.
But for better understanding the threads, we are explaining it in the 5 states.
The life cycle of the thread in java is controlled by JVM.


1) New
The thread is in new state if you create an instance of Thread class but before the invocation of start() method.
2) Runnable
The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread.
3) Running
The thread is in running state if the thread scheduler has selected it.
4) Non-Runnable (Blocked)
This is the state when the thread is still alive, but is currently not eligible to run.
5) Terminated
A thread is in terminated or dead state when its run() method exits.
How to create thread
There are two ways to create a thread:
1.By extending Thread class
2.By implementing Runnable interface.

Thread class:
Thread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface.
Commonly used Constructors of Thread class:
oThread()
oThread(String name)
oThread(Runnable r)
oThread(Runnable r,String name)


Runnable interface:
The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run().
1.public void run(): is used to perform action for a thread.

Starting a thread:
start() method of Thread class is used to start a newly created thread. It performs following tasks:
oA new thread starts(with new callstack).
oThe thread moves from New state to the Runnable state.
oWhen the thread gets a chance to execute, its target run() method will run.


1) Java Thread Example by extending Thread class
1.class Multi extends Thread{  
2.public void run(){  
3.System.out.println("thread is running...");  
4.}  
5.public static void main(String args[]){  
6.Multi t1=new Multi();  
7.t1.start();  
8. }  
9.}  
Output:thread is running...

2) Java Thread Example by implementing Runnable interface
1.class Multi3 implements Runnable{  
2.public void run(){  
3.System.out.println("thread is running...");  
4.}  
5.  
6.public static void main(String args[]){  
7.Multi3 m1=new Multi3();  
8.Thread t1 =new Thread(m1);  
9.t1.start();  
10. }  
11.}  
Output:thread is running...
If you are not extending the Thread class,your class object would not be treated as a thread object.So you need to explicitely create Thread class object.We are passing the object of your class that implements Runnable so that your class run() method may execute.

Thread Scheduler in Java
Thread scheduler in java is the part of the JVM that decides which thread should run.
	The thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads.

Difference between preemptive scheduling and time slicing
Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.
Sleep method in java
The sleep() method of Thread class is used to sleep a thread for the specified amount of time
 Daemon Thread in Java
Daemon thread in java is a service provider thread that provides services to the user thread. Its life depend on the mercy of user threads i.e. when all the user threads dies, JVM terminates this thread automatically.
There are many java daemon threads running automatically e.g. gc, finalizer etc.
It is a low priority thread.
No.	Method	Description
1)	public void setDaemon(boolean status)	is used to mark the current thread as daemon thread or user thread.
2)	public boolean isDaemon()	is used to check that current is daemon.
Java Thread Pool
Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times.
In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again.

Multithreading Interview Questions
1) What is multithreading?
Multithreading is a process of executing multiple threads simultaneously. Multithreading is used to obtain the multitasking. It consumes less memory and gives the fast and efficient performance. Its main advantages are:
oThreads share the same address space.
oThe thread is lightweight.
oThe cost of communication between the processes is low.
More details.

2) What is the thread?
A thread is a lightweight subprocess. It is a separate path of execution because each thread runs in a different stack frame. A process may contain multiple threads. Threads share the process resources, but still, they execute independently.
More details.

3) Differentiate between process and thread?
There are the following differences between the process and thread.
oA Program in the execution is called the process whereas; A thread is a subset of the process
oProcesses are independent whereas threads are the subset of process.
oProcess have different address space in memory, while threads contain a shared address space.
oContext switching is faster between the threads as compared to processes.
oInter-process communication is slower and expensive than inter-thread communication.
oAny change in Parent process doesn't affect the child process whereas changes in parent thread can affect the child thread.


4) What do you understand by inter-thread communication?
oThe process of communication between synchronized threads is termed as inter-thread communication.
oInter-thread communication is used to avoid thread polling in Java.
oThe thread is paused running in its critical section, and another thread is allowed to enter (or lock) in the same critical section to be executed.
oIt can be obtained by wait(), notify(), and notifyAll() methods.

5) What is the purpose of wait() method in Java?
The wait() method is provided by the Object class in Java. This method is used for inter-thread communication in Java. The java.lang.Object.wait() is used to pause the current thread, and wait until another thread does not call the notify() or notifyAll() method. Its syntax is given below.
public final void wait()

6) Why must wait() method be called from the synchronized block?
We must call the wait method otherwise it will throw java.lang.IllegalMonitorStateException exception. Moreover, we need wait() method for inter-thread communication with notify() and notifyAll(). Therefore It must be present in the synchronized block for the proper and correct communication.

7) What are the advantages of multithreading?
Multithreading programming has the following advantages:
oMultithreading allows an application/program to be always reactive for input, even already running with some background tasks
oMultithreading allows the faster execution of tasks, as threads execute independently.
oMultithreading provides better utilization of cache memory as threads share the common memory resources.
oMultithreading reduces the number of the required server as one server can execute multiple threads at a time.

8) What are the states in the lifecycle of a Thread?
A thread can have one of the following states during its lifetime:
1.New: In this state, a Thread class object is created using a new operator, but the thread is not alive. Thread doesn't start until we call the start() method.
2.Runnable: In this state, the thread is ready to run after calling the start() method. However, the thread is not yet selected by the thread scheduler.
3.Running: In this state, the thread scheduler picks the thread from the ready state, and the thread is running.
4.Waiting/Blocked: In this state, a thread is not running but still alive, or it is waiting for the other thread to finish.
5.Dead/Terminated: A thread is in terminated or dead state when the run() method exits.


9) What is the difference between preemptive scheduling and time slicing?
Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.

10) What is context switching?
In Context switching the state of the process (or thread) is stored so that it can be restored and execution can be resumed from the same point later. Context switching enables the multiple processes to share the same CPU.

11) Differentiate between the Thread class and Runnable interface for creating a Thread?
The Thread can be created by using two ways.
oBy extending the Thread class
oBy implementing the Thread class
However, the primary differences between both the ways are given below:
oBy extending the Thread class, we cannot extend any other class, as Java does not allow multiple inheritances while implementing the Runnable interface; we can also extend other base class(if required).
oBy extending the Thread class, each of thread creates the unique object and associates with it while implementing the Runnable interface; multiple threads share the same object
oThread class provides various inbuilt methods such as getPriority(), isAlive and many more while the Runnable interface provides a single method, i.e., run().

12) What does join() method?
The join() method waits for a thread to die. In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task. Join method is overloaded in Thread class in the following ways.
opublic void join()throws InterruptedException
opublic void join(long milliseconds)throws InterruptedException
More details.

13) Describe the purpose and working of sleep() method.
The sleep() method in java is used to block a thread for a particular time, which means it pause the execution of a thread for a specific time. There are two methods of doing so.
Syntax:
opublic static void sleep(long milliseconds)throws InterruptedException
opublic static void sleep(long milliseconds, int nanos)throws InterruptedException
Working of sleep() method
When we call the sleep() method, it pauses the execution of the current thread for the given time and gives priority to another thread(if available). Moreover, when the waiting time completed then again previous thread changes its state from waiting to runnable and comes in running state, and the whole process works so on till the execution doesn't complete.

14) What is the difference between wait() and sleep() method?
wait()	sleep()
1) The wait() method is defined in Object class.	The sleep() method is defined in Thread class.
2) The wait() method releases the lock.	The sleep() method doesn't release the lock.

15) Is it possible to start a thread twice?
No, we cannot restart the thread, as once a thread started and executed, it goes to the Dead state. Therefore, if we try to start a thread twice, it will give a runtimeException "java.lang.IllegalThreadStateException". Consider the following example.
1.public class Multithread1 extends Thread  
2.{  
3.   public void run()  
4.    {  
5.      try {  
6.          System.out.println("thread is executing now........");  
7.      } catch(Exception e) {  
8.      }   
9.    }  
10.    public static void main (String[] args) {  
11.        Multithread1 m1= new Multithread1();  
12.        m1.start();  
13.        m1.start();  
14.    }  
15.}  
Output
thread is executing now........
Exception in thread "main" java.lang.IllegalThreadStateException
	at java.lang.Thread.start(Thread.java:708)
	at Multithread1.main(Multithread1.java:13)
More details.

16) Can we call the run() method instead of start()?
Yes, calling run() method directly is valid, but it will not work as a thread instead it will work as a normal object. There will not be context-switching between the threads. When we call the start() method, it internally calls the run() method, which creates a new stack for a thread while directly calling the run() will not create a new stack.
More details.

17) What about the daemon threads?
The daemon threads are the low priority threads that provide the background support and services to the user threads. Daemon thread gets automatically terminated by the JVM if the program remains with the daemon thread only, and all other user threads are ended/died. There are two methods for daemon thread available in the Thread class:
opublic void setDaemon(boolean status): It used to mark the thread daemon thread or a user thread.
opublic boolean isDaemon(): It checks the thread is daemon or not.
More details.

18)Can we make the user thread as daemon thread if the thread is started?
No, if you do so, it will throw IllegalThreadStateException. Therefore, we can only create a daemon thread before starting the thread.
1.class Testdaemon1 extends Thread{    
2.public void run(){  
3.          System.out.println("Running thread is daemon...");  
4.}  
5.public static void main (String[] args) {  
6.      Testdaemon1 td= new Testdaemon1();  
7.      td.start();  
8.      setDaemon(true);// It will throw the exception: td.   
9.   }  
10.}  
Output
Running thread is daemon...
Exception in thread "main" java.lang.IllegalThreadStateException
at java.lang.Thread.setDaemon(Thread.java:1359)
at Testdaemon1.main(Testdaemon1.java:8)
More details.

19)What is shutdown hook?
The shutdown hook is a thread that is invoked implicitly before JVM shuts down. So we can use it to perform clean up the resource or save the state when JVM shuts down normally or abruptly. We can add shutdown hook by using the following method:
1.public void addShutdownHook(Thread hook){}    
2.Runtime r=Runtime.getRuntime();  
3.r.addShutdownHook(new MyThread());  
Some important points about shutdown hooks are :
oShutdown hooks initialized but can only be started when JVM shutdown occurred.
oShutdown hooks are more reliable than the finalizer() because there are very fewer chances that shutdown hooks not run.
oThe shutdown hook can be stopped by calling the halt(int) method of Runtime class.
More details.

20)When should we interrupt a thread?
We should interrupt a thread when we want to break out the sleep or wait state of a thread. We can interrupt a thread by calling the interrupt() throwing the InterruptedException.
More details.

21) What is the synchronization?
Synchronization is the capability to control the access of multiple threads to any shared resource. It is used:

1.To prevent thread interference.
2.To prevent consistency problem.
When the multiple threads try to do the same task, there is a possibility of an erroneous result, hence to remove this issue, Java uses the process of synchronization which allows only one thread to be executed at a time. Synchronization can be achieved in three ways:
oby the synchronized method
oby synchronized block
oby static synchronization
Syntax for synchronized block
1.synchronized(object reference expression)  
2.    {  
3.        //code block  
4.    }  
5.      
More details.

22) What is the purpose of the Synchronized block?
The Synchronized block can be used to perform synchronization on any specific resource of the method. Only one thread at a time can execute on a particular resource, and all other threads which attempt to enter the synchronized block are blocked.
oSynchronized block is used to lock an object for any shared resource.
oThe scope of the synchronized block is limited to the block on which, it is applied. Its scope is smaller than a method.
More details.

23)Can Java object be locked down for exclusive use by a given thread?
Yes. You can lock an object by putting it in a "synchronized" block. The locked object is inaccessible to any thread other than the one that explicitly claimed it.

24) What is static synchronization?
If you make any static method as synchronized, the lock will be on the class not on the object. If we use the synchronized keyword before a method so it will lock the object (one thread can access an object at a time) but if we use static synchronized so it will lock a class (one thread can access a class at a time). More details.

25)What is the difference between notify() and notifyAll()?
The notify() is used to unblock one waiting thread whereas notifyAll() method is used to unblock all the threads in waiting state.

26)What is the deadlock?
Deadlock is a situation in which every thread is waiting for a resource which is held by some other waiting thread. In this situation, Neither of the thread executes nor it gets the chance to be executed. Instead, there exists a universal waiting state among all the threads. Deadlock is a very complicated situation which can break our code at runtime.
More details.

27) How to detect a deadlock condition? How can it be avoided?
We can detect the deadlock condition by running the code on cmd and collecting the Thread Dump, and if any deadlock is present in the code, then a message will appear on cmd.
Ways to avoid the deadlock condition in Java:
oAvoid Nested lock: Nested lock is the common reason for deadlock as deadlock occurs when we provide locks to various threads so we should give one lock to only one thread at some particular time.
oAvoid unnecessary locks: we must avoid the locks which are not required.
oUsing thread join: Thread join helps to wait for a thread until another thread doesn't finish its execution so we can avoid deadlock by maximum use of join method.

28) What is Thread Scheduler in java?
In Java, when we create the threads, they are supervised with the help of a Thread Scheduler, which is the part of JVM. Thread scheduler is only responsible for deciding which thread should be executed. Thread scheduler uses two mechanisms for scheduling the threads: Preemptive and Time Slicing.
Java thread scheduler also works for deciding the following for a thread:
oIt selects the priority of the thread.
oIt determines the waiting time for a thread
oIt checks the Nature of thread

29) Does each thread have its stack in multithreaded programming?
Yes, in multithreaded programming every thread maintains its own or separate stack area in memory due to which every thread is independent of each other.

30) How is the safety of a thread achieved?
If a method or class object can be used by multiple threads at a time without any race condition, then the class is thread-safe. Thread safety is used to make a program safe to use in multithreaded programming. It can be achieved by the following ways:
oSynchronization
oUsing Volatile keyword
oUsing a lock based mechanism
oUse of atomic wrapper classes

31) What is race-condition?
A Race condition is a problem which occurs in the multithreaded programming when various threads execute simultaneously accessing a shared resource at the same time. The proper use of synchronization can avoid the Race condition.

32) What is the volatile keyword in java?
Volatile keyword is used in multithreaded programming to achieve the thread safety, as a change in one volatile variable is visible to all other threads so one variable can be used by one thread at a time.

33) What do you understand by thread pool?
oJava Thread pool represents a group of worker threads, which are waiting for the task to be allocated.
oThreads in the thread pool are supervised by the service provider which pulls one thread from the pool and assign a job to it.
oAfter completion of the given task, thread again came to the thread pool.
oThe size of the thread pool depends on the total number of threads kept at reserve for execution.
The advantages of the thread pool are :
oUsing a thread pool, performance can be enhanced.
oUsing a thread pool, better system stability can occur.

SYNCRONISATION-
Synchronization in Java
Synchronization in java is the capability to control the access of multiple threads to any shared resource.
Java Synchronization is better option where we want to allow only one thread to access the shared resource.

Why use Synchronization
The synchronization is mainly used to
1.To prevent thread interference.
2.To prevent consistency problem.

Types of Synchronization
There are two types of synchronization
1.Process Synchronization
2.Thread Synchronization
Here, we will discuss only thread synchronization.

Thread Synchronization
There are two types of thread synchronization mutual exclusive and inter-thread communication.
1.Mutual Exclusive
1.Synchronized method.
2.Synchronized block.
3.static synchronization.
2.Cooperation (Inter-thread communication in java)

Mutual Exclusive
Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java:
1.by synchronized method
2.by synchronized block
3.by static synchronization

Concept of Lock in Java
Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object's fields has to acquire the object's lock before accessing them, and then release the lock when it's done with them.
From Java 5 the package java.util.concurrent.locks contains several lock implementations.
Java synchronized method
If you declare any method as synchronized, it is known as synchronized method.
Synchronized method is used to lock an object for any shared resource.
When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task.
Synchronized Block in Java
Synchronized block can be used to perform synchronization on any specific resource of the method.
Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block.
If you put all the codes of the method in the synchronized block, it will work same as the synchronized method.
Points to remember for Synchronized block
oSynchronized block is used to lock an object for any shared resource.
oScope of synchronized block is smaller than the method.
Syntax to use synchronized block
1.synchronized (object reference expression) {   
2.  //code block   
3.}  



Static Synchronization
If you make any static method as synchronized, the lock will be on the class not on object.

Deadlock in java
Deadlock in java is a part of multithreading. Deadlock can occur in a situation when a thread is waiting for an object lock, that is acquired by another thread and second thread is waiting for an object lock that is acquired by first thread. Since, both threads are waiting for each other to release the lock, the condition is called deadlock.


next →← prev
Inter-thread communication in Java
Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other.
Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.It is implemented by following methods of Object class:
owait()
onotify()
onotifyAll()
1) wait() method
Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.
2) notify() method
Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. Syntax:
public final void notify()

3) notifyAll() method
Wakes up all threads that are waiting on this object's monitor. Syntax:
public final void notifyAll()

The point to point explanation of the above diagram is as follows:
1.Threads enter to acquire lock.
2.Lock is acquired by on thread.
3.Now thread goes to waiting state if you call wait() method on the object. Otherwise it releases the lock and exits.
4.If you call notify() or notifyAll() method, thread moves to the notified state (runnable state).
5.Now thread is available to acquire lock.
6.After completion of the task, thread releases the lock and exits the monitor state of the object.

Why wait(), notify() and notifyAll() methods are defined in Object class not Thread class?
It is because they are related to lock and object has a lock.


EXCEPTION HANDLING-

The Exception Handling in Java is one of the powerful mechanism to handle the runtime errors so that normal flow of the application can be maintained.



In Java, an exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.

Suppose there are 10 statements in your program and there occurs an exception at statement 5, the rest of the code will not be executed i.e. statement 6 to 10 will not be executed. If we perform exception handling, the rest of the statement will be executed. That is why we use exception handling in Java.

Exception hierarchy-The topmost class is throwable class.(‘able’=interface for eg cloneable,serializable etc but throwable is a class)
                      
Java Multi-catch block
A try block can be followed by one or more catch blocks. Each catch block must contain a different exception handler. So, if you have to perform different tasks at the occurrence of different exceptions, use java multi-catch block.
Points to remember
oAt a time only one exception occurs and at a time only one catch block is executed.
oAll catch blocks must be ordered from most specific to most general, i.e. catch for ArithmeticException must come before catch for Exception.
Java Nested try block
The try block within a try block is known as nested try block in java.
Why use nested try block
Sometimes a situation may arise where a part of a block may cause one error and the entire block itself may cause another error. In such cases, exception handlers have to be nested.
1.try  
2.{   statement 1;  
3.    try  
4.    {           statement 1;          } catch(Exception e) {}            
5.}  
6.catch(Exception e) {}  

Why use java finally
oFinally block in java can be used to put "cleanup" code such as closing a file, closing connection etc.

Rule: For each try block there can be zero or more catch blocks, but only one finally block.

Note: The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).

Java Exception propagation
An exception is first thrown from the top of the stack and if it is not caught, 
it drops down the call stack to the previous method,
If not caught there, the exception again drops down to the previous method, 
and so on until they are caught or until they reach the very bottom of the call stack.
This is called exception propagation.
Rule: By default Unchecked Exceptions are forwarded in calling chain (propagated).
Rule: By default, Checked Exceptions are not forwarded in calling chain (propagated)



Any exception that is thrown out of a method must be specified as such by a throws clause.
The "throws" keyword is used to declare exceptions. It doesn't throw an exception. It specifies that there may occur an exception in the method. It is always used with method signature.
Java throws keyword
The Java throws keyword is used to declare an exception. It gives an information to the programmer that there may occur an exception so it is better for the programmer to provide the exception handling code so that normal flow can be maintained.
Exception Handling is mainly used to handle the checked exceptions. If there occurs any unchecked exception such as NullPointerException, it is programmers fault that he is not performing check up before the code being used.
Syntax of java throws
1.return_type method_name() throws exception_class_name{  
2.//method code  
3.}  

Which exception should be declared
Ans) checked exception only, because:
ounchecked Exception: under your control so correct your code.
oerror: beyond your control e.g. you are unable to do anything if there occurs VirtualMachineError or StackOverflowError.

Advantage of Java throws keyword
Now Checked Exception can be propagated (forwarded in call stack).
It provides information to the caller of the method about the exception.
Rule: If you are calling a method that declares an exception, you must either caught or declare the exception.
There are two cases:
1.Case1:You caught the exception i.e. handle the exception using try/catch.
2.Case2:You declare the exception i.e. specifying throws with the method.

Case1: You handle the exception
oIn case you handle the exception, the code will be executed fine whether exception occurs during the program or not.

Case2: You declare the exception
oA)In case you declare the exception, if exception does not occur, the code will be executed fine.
oB)In case you declare the exception if exception occures, an exception will be thrown at runtime because throws does not handle the exception.
o

Difference between throw and throws in Java
oThere are many differences between throw and throws keywords. A list of differences between throw and throws are given below:
No.	Throw	throws
1)	Java throw keyword is used to explicitly throw an exception.	Java throws keyword is used to declare an exception.
2)	Checked exception cannot be propagated using throw only.	Checked exception can be propagated with throws.
3)	Throw is followed by an instance.	Throws is followed by class.
4)	Throw is used within the method.	Throws is used with the method signature.
5)	You cannot throw multiple exceptions.	You can declare multiple exceptions e.g.
public void method()throws IOException,SQLException.

Que) Can we rethrow an exception?
Yes, by throwing same exception in catch block.

Difference between final, finally and finalize
There are many differences between final, finally and finalize. A list of differences between final, finally and finalize are given below:
No.	final	Finally	Finalize
1)	Final is used to apply restrictions on class, method and variable. Final class can't be inherited, final method can't be overridden and final variable value can't be changed.	Finally is used to place important code, it will be executed whether exception is handled or not.	Finalize is used to perform clean up processing just before object is garbage collected.
2)	Final is a keyword.	Finally is a block.	Finalize is a method.

ExceptionHandling with MethodOverriding in Java
There are many rules if we talk about methodoverriding with exception handling. 
The Rules are as follows:
oIf the superclass method does not declare an exception
oIf the superclass method does not declare an exception, 
subclass overridden method cannot declare the checked exception
 but it can declare unchecked exception.
oIf the superclass method declares an exception
oIf the superclass method declares an exception, 
subclass overridden method can declare same, subclass exception or 
no exception but cannot declare parent exception.

https://www.javatpoint.com/exception-handling-with-method-overriding  ( IMPORTANT!!! )
https://www.javatpoint.com/custom-exception


Difference between Checked and Unchecked Exceptions
1) Checked Exception
The classes which directly inherit Throwable class except RuntimeException and Error are known as checked exceptions e.g. IOException, SQLException etc. Checked exceptions are checked at compile-time.
2) Unchecked Exception
The classes which inherit RuntimeException are known as unchecked exceptions e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. Unchecked exceptions are not checked at compile-time, but they are checked at runtime.
3) Error
Error is irrecoverable e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc.
INNER CLASS-

Difference between nested class and inner class in Java
There are two types of nested classes non-static and static nested classes.The non-static nested classes are also known as inner classes.
https://www.javatpoint.com/java-inner-class#nesteddiff (IMPORTANT !!!) ENTIRE TOPIC.


GENERICS-
	A generic type is a generic class or interface that is parameterized over types. 
NON-GENERIC
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
z	}

GENERIC
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}


We can also pass multiple Type parameters in Generic classes.

class Test<T, U>

Test <String, Integer> obj = 
            new Test<String, Integer>("GfG", 15);

Generic Functions:

We can also write generic functions that can be called with different types of arguments based on the type of arguments passed to generic method, the compiler handles each method.
Static and non-static generic methods are allowed, as well as generic class constructors.
 For static generic methods, the type parameter section must appear before the method's return type.
STATIC - public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2)

NON STATIC- public <E> void method(E param)

*What is type erasure?
Generics is implemented using Type erasure, compiler erases all type related information during compile time and no type related information is available during runtime. for example List<String> is represented by only List at runtime.

*What is Bounded and Unbounded wildcards in Generics ?

Bounded Wildcards are those which impose bound on Type. there are two kinds of Bounded wildcards <? extends T> which impose an upper bound by ensuring that type must be sub class of T and <? super T> where its imposing lower bound by ensuring Type must be super class of T. This Generic Type must be instantiated with Type within bound otherwise it will result in compilation error. On the other hand <?> represent and unbounded type because <?> can be replace with any Type.

NORMAL WAY-public static void printList(List<Object> list)
UNBOUNDED-public static void printList(List<?> list)

. How to write a generic method which accepts generic argument and return Generic Type?

public V put(K key, V value) {
        return cache.put(key, value);
}


Can we use generics with array?
NO

Q9. What Is a Wildcard Type?
A wildcard type represents an unknown type. It's detonated with a question mark as follows:
public static void consumeListOfWildcardType(List<?> list)
Here, we are specifying a list which could be of any type. We could pass a list of anything into this method.
Q10. What Is an Upper Bounded Wildcard?
An upper bounded wildcard is when a wildcard type inherits from a concrete type. This is particularly useful when working with collections and inheritance.

Q11. What Is an Unbounded Wildcard?
An unbounded wildcard is a wildcard with no upper or lower bound, that can represent any type.
What Is a Lower Bounded Wildcard?
A lower bounded wildcard is when instead of providing an upper bound, we provide a lower bound by using the super keyword. In other words, a lower bounded wildcard means we are forcing the type to be a superclass of our bounded type. Let's try this with an example:
	public static void addDogs(List<? super Animal> list) {
	list.add(new Dog("tom"))
	}


SERIALIZATION AND DE-SERIALIZATION-
Serialization in Java is a mechanism of writing the state of an object into a byte-stream. It is mainly used in Hibernate, RMI, JPA, EJB and JMS technologies.
The reverse operation of serialization is called deserialization where byte-stream is converted into an object. The serialization and deserialization process is platform-independent, it means you can serialize an object in a platform and deserialize in different platform.
For serializing the object, we call the writeObject() method ObjectOutputStream, and for deserialization we call the readObject() method of ObjectInputStream class.
We must have to implement the Serializable interface for serializing the object.
Advantages of Java Serialization
It is mainly used to travel object's state on the network (which is known as marshaling).

java.io.Serializable interface
Serializable is a marker interface (has no data member and method). It is used to "mark" Java classes so that the objects of these classes may get a certain capability. The Cloneable and Remote are also marker interfaces.
It must be implemented by the class whose object you want to persist.
The String class and all the wrapper classes implement the java.io.Serializable interface by default.
Java Serialization with the static data member
If there is any static data member in a class, it will not be serialized because static is the part of class not object.
Java Serialization with array or collection
Rule: In case of array or collection, all the objects of array or collection must be serializable. If any object is not serialiizable, serialization will be failed.
Java Transient Keyword
Java transient keyword is used in serialization. If you define any data member as transient, it will not be serialized.
Let's take an example, I have declared a class as Student, it has three data members id, name and age. If you serialize the object, all the values will be serialized but I don't want to serialize one value, e.g. age then we can declare the age data member as transient.


1.import java.io.Serializable;  
2.public class Student implements Serializable{  
3. int id;  
4. String name;  
5. transient int age;//Now it will not be serialized  
6. public Student(int id, String name,int age) {  
7.  this.id = id;  
8.  this.name = name;  
9.  this.age=age;  
10. }  
11.}  

Now write the code to serialize the object.

1.import java.io.*;  
2.class PersistExample{  
3. public static void main(String args[])throws Exception{  
4.  Student s1 =new Student(211,"ravi",22);//creating object  
5.  //writing object into file  
6.  FileOutputStream f=new FileOutputStream("f.txt");  
7.  ObjectOutputStream out=new ObjectOutputStream(f);  
8.  out.writeObject(s1);  
9.  out.flush();  
10.  
11.  out.close();  
12.  f.close();  
13.  System.out.println("success");  
14. }  
15.} 

Output:
success

Now write the code for deserialization.

1.import java.io.*;  
2.class DePersist{  
3. public static void main(String args[])throws Exception{  
4.  ObjectInputStream in=new ObjectInputStream(new FileInputStream("f.txt"));  
5.  Student s=(Student)in.readObject();  
6.  System.out.println(s.id+" "+s.name+" "+s.age);  
7.  in.close();  
8. }  
9.}  
211 ravi 0
As you can see, printing age of the student returns 0 because value of age was not serialized.

	
GETTER/SETTER-
