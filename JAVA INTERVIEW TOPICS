THE JAVA PLATFORM-
	Java platform has 2 components.
	1. JVM (used to achieve platform independence)
	2. JAVA Application Programming Interface (API) -(Bunch of librabies and methods that we use)

	Used to run languages that are not JAVA eg.Groovy, Scala etc are not JAVA but have been written for the JAVA platform
	The java compiler compiles your source code to an intermediate language (byte code) that is interpreted by the JVM
	byte code is NOT machine code that gets executed directly. Instead the JVM translates the byte code to machine code, which gets run by the actual platform.
	byte code is platform independent
	JAVA APPLICATION --> JAVA COMPILER --> BYTE CODE --> JVM --> MACHINE CODE --> HANDWARE/OS

	What components makes up the Java Runtime Environment (JRE)?
	Ans:
	1. JVM
	2. JAVA Application Programming Interface (API) 
	
	True or False: The JVM is able to run languages other than Java?
	Ans: True

EDITIONS OF JAVA:
	1. JAVA EE(ENTERPRISE) (build distributed applications. eg using web features in our applications)
	2. JAVA SE(STANDARD) (basic codiing)
	3. JAVA ME(MICRO)(Used in IOT eg code for automatic fans)
	JAVA EE  is a superset of JAVA SE and JAVA SE is superset of JAVA ME
	JAVA EE --> JAVA SE --> JAVA ME

MAIN METHOD:
	public static void main(String[] args) can also be written as  static public void main(String[] args)
	the order doesn't matter as long as it is to the left of returntype	 
	It must return "void."
	The name "main" must be written in all lowercase
	It must declare a String array parameter (where the square brackets may be written to the right of String or to the right of the identifier).
	The identifier for the String array may be named anything you'd like (though, by convention, it is typically "args").
	
	Is this correct?
	static public void main(String command_Line_Arguments[])
	Ans: YES

COMPILING CODE:
	Using javac filename.java will create a filname.class file which is the byte code(binary). Then "java filename" cmd will run the .class file and give an output. 


CLASS-
	A class is a user defined blueprint or prototype from which objects are created.
	It represents the set of properties or methods that are common to all objects of one type
	For eg, a blueprint of a house tells you a lot about the structure and characteristics but you cannot live in a blueprint right?
	So we have to create a actual house(obj) out of the blueprint to order to live in it.

	public class HelloWorld{
	...
	}
	class HelperClass{
	...
	}
	In the above eg
	NOTE: Each file may contain only 1 'public' top level class(and that will be the name of the file)
	Other top level classes may be added to the same file but they must not list the access modifier.

	A method that declares a return type of void cannot return any value.  So, for example, the following is illegal and would not compile:

	public void doSomething() {
	    return "Hello!";
	}
	It is, however, legal (though uncommon) to just use the return statement.  
	
	public void doSomething() {
	    return;
	}
	As mentioned, it's pretty uncommon (and useless) to see a return like that on it's own... though it can be used to end a method inside of a control structure.

OBJECT:
	An Object is an instance of a Class.
	objects are bundles of state and behaviour
	When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created)
	Memory is allocated. So using new keyword actually creates the obj.
	Customer 		c 	= 	new 		Customer();
	Reference Type		Ref var		keyword		Object type
	
	just like in int c=45; we expect that c will receive a value of type integer, similarly while creating an obj we expect the ref variable will receive a value of Ref type.
	Parent child= new child(); is possible because child class is a type of parent class as it is extending it.
	The technical term to create an obj is instantiation
	C c =new C("a");
	C c =new C("b");
	C c =new C("c"); is completly fine as the ref is now pointing to diff obj. The garbage collectors looks for objs which are not reffered by anybody and destroys them.
	
	What's a "member" of a class or an object?
	A:  A member is any piece of state or behavior that belongs to the class or object.  
	In general, a member refers to any field, method, or constructor in a class.  
	However, sometimes the term "class member" is used to specifically refer to static methods and static variables.

	Ways to create obj in JAVA
	
		Using new keyword:
		GFG obj = new GFG();
		 
		Using new instance:
		A bit complex so skip the implementation
		
		Using clone() method:
		GFG obj1 = new GFG();
		GFG obj2 = (GFG)obj1.clone();
		
		Using deserialization:
		Whenever we serialize and then deserialize an object, JVM creates a separate object. 
		In deserialization, JVM doesn’t use any constructor to create the object. 
		
		Using newInstance() method of Constructor class
		This is similar to the newInstance() method of a class. There is one newInstance() method in the java.lang.reflect.Constructor class which we can use to create objects. 
		It can also call the parameterized constructor, and private constructor by using this newInstance() method. Both newInstance() methods are known as reflective ways to create objects. 
		In fact newInstance() method of Class internally uses newInstance() method of Constructor class. 
		Constructor<GFG> constructor
		                = GFG.class.getDeclaredConstructor();
		 
		            GFG r = constructor.newInstance();
		

PRIMITIVE DATA TYPES- 
	8 datatypes: byte,short,int, long, float, double, boolean, char(String is a class from JAVA API and not a primitive type)
	Default values:
	byte        0
	short       0
	int         0
	long        0
	float       0.0f
	double      0.0d
	char        '\u0000' or empty
	boolean     false
	*Default value for String(or any JAVA obj) is null*
	Everything else in JAVA is an obj
	PRimitive just has a single value(state) unlike obj which has state(value) and behaviour(methods)
	int chaptersToStudy = 3, 4, 5; // ILLEGAL
	int chaptersToStudy = 3; //LEGAL

	2 in an int
	2L or 2l is a long
	2.2 is a double (it is by default double if you use .)
	2.2F or 2.2f is float
	2.2D or 2.2d is double(it's okay to skip D or d as 2.2 is anyway double)

	public static void main(String[] args) {
	float flt = 100.00F; // A - Ok
	float flt = (float) 1_11.00; // B - Ok
	Float flt = 100.00; // C - Error - need cast to Float.
	double y1 = 203.22; float flt = y1; // D - Error - need cast to float.
	int y2 = 100; float flt = (float) y2 ; // F - Ok

	char c;
	boolean b;
	float f;
	
	void printAll() {
	System.out.println("c = "+c);// ' ' ie empty
	System.out.println("b = "+b);//false
	System.out.println("f = "+f);//0.0
	}

	Working with ocatal and hexadecimal integers
	Any integer starting with 0 is an octal number
	Any integer starting with 0x is a hex number
	eg
	myInt=070;// 70 octal is 56 in decimal notation
	HOW TO CONVERT OCTAL TO DECIMAL
	275 octal to decimal
	write down the place value for each digit
	8^2	8^1	8^0
	64	8	1
	2	7	5
	multiple place value of each digit
	(2x64)+(7x8)+(5x1)=128+56+5=189//decimal of 275 

	for 070 ie our eg.

	8^1	8^0
	8	1
	7	0
	(7x8)+(0x1)=56

	How to convert decimal to octal
	eg 
	convert 139 to decimal
	1. Look at what octal place values we need
	powers of 1,8,64,512,4096...
	our num is 139 so we go upto 64
	so
	8^2	8^1	8^0
	64	8	0
	?	?	?
	2. Divide 139 by highest place value number
	139/64=2 with R=11
	8^2	8^1	8^0
	64	8	0
	2	?	?
	3. Now divide the remainder by the next(lower) power of 8
	11/8=1 with R=3
	8^2	8^1	8^0
	64	8	0
	2	1	?
	4.divide the remainder by the next(lower) power of 8
	3/1=3 with R=0
	8^2	8^1	8^0
	64	8	1
	2	1	3
	5. multply and add
	(2x64)+(1x8)+(3x1)=213
	
	myInt=0x7E;// 7E is 126 in decimal notation
	How to convert hex to decimal
	search online
	for this eg 7E
	7x16^1 + 14*16^0= 112+14=126
	

	As of JAVA 7, new binary literal support was added
	You can define a binary literal with 0b or 0B prefix
	int myInt=0b101 //101 ie 0101 is 5 in decimal notation

	Also, underscores can be used in numeric literals for better readablity of code
	int num=1234567; is equivalent to int num=1_234_567
	double num=1.234567 is equivalent to double num=1.234_567

	Rules for underscore:
	cannot be used for first or final character
	cannot be used immediately in front or after a decimal	
	int x=12_345; //legal
	int x 12_345_; //illegal

	double x=12_345.67 //legal
	double x=12_345_.67 //illegal
	
	

STACKS AND HEAP-
	Memory in JAVA is managed by Stacks and Heap
	Heap is a large portion of memory where all objects are going to live and stack is short memory where we have our ref vars etc
	Stack is a list of references that are defined within a given block of code(scope i.e. {}).
	Cust c =new Cust("a");
	c --> stack
	new Cust("a") --> heap

SCOPE-


CONSTRUCTOR-
	Constructor is a block of code that initializes the newly created object.
	It is special type of method which has same name as the class name.
	It does NOT have a return type.
	If you see any cons with return type, it's no more a cons, it is treated as a normal method.
	For a calling another cons inside the current cons use this
		eg for calling no-arg cons
		this();
		eg for calling parameterized cons
		this("Sushmit", 22);
		this should always be in the first line of the cons
		this();/this("Sushmit", 22); cannot be used in any other other method
	There are four types of constructors: Default, No-arg constructor, Parameterized and Copy.

	If you do not implement any constructor in your class, 
	Java compiler inserts a default constructor into your code on your behalf.
	This constructor is known as default constructor. 
	If you implement any constructor then you no longer receive a default constructor from Java compiler.
	In that case, if you try to call a no arg/default cons, it will give a compile time error

	Constructor with no arguments is known as no-arg constructor.
	The signature is same as default constructor, 
	however body can have any code unlike default constructor where the body of the constructor is empty.

	Constructor with arguments(or you can say parameters) is known as Parameterized constructor.
	If you create a parameterized cons and if you want to create a obj without parameters then it will
	throw and error. You should have a no-arg cons for that.
	
	A copy constructor is used for copying the values of one object to another object.

	You can call a method inside a constructor
	to call a constructor inside another cons, call it using this keyword and not by using it's name
		NOTE: INITIALIZATION BLOCK IS CALLED EVEN BEFORE THE CONSTRUCTOR
	

	
	With the following class:

	public class Car {
	    String type;
	    String color;
	    Car( String color, String model ) {
	        System.out.println("The car is a " + color + " " + type);
	    }
	}
	What will the output be after an object is instantiated: Car myCar = new Car("Silver", "Sedan");
	Ans: The car is a Silver null
	Explanantion:  notice that the second Car constructor is "model" rather than "type." Yet the System.out.println statement is referencing "type." 
	Since type is an instance variable it is legal to reference even though it hasn't been initialized with an explicit value (it has a default value: "null.")

	Q:  What's the difference between a "default" and a "no-arg" constructor?
	
	A:  A "no-arg" constructor is one that lists no parameters (it takes no arguments but can contain lines of code).  
	A "default" constructor is a "no-arg" constructor that is created by the compiler, in the event that you don't explicitly create one yourself.

	Q: public class Car{
				String colour="Green"; //in line initialization
				{
					colour= "Red";  //initialization block
				}
				Car (){
					colour="Blue";
				  }
				}
	Explain the intialization step wise
	ANS: First the String colour varialble is created and assigned null-->Green-->Red-->Blue


	Q: public class Car{
				{
					colour= "Red";  //initialization block
				}
				String colour="Green"; //in line initialization
				
				Car (){
					colour="Blue";
				  }
				}
	Explain the intialization step wise
	ANS: First the String colour varialble is created and assigned null-->Red-->Green-->Blue

	Q: public class Car{

				Car (){
					colour="Blue";
				  }

				{
					colour= "Red";  //initialization block
				}
				String colour="Green"; //in line initialization
				
				}
	Explain the intialization step wise
	ANS: First the String colour varialble is created and assigned null-->Red-->Green-->Blue

	So placement of initialzation block matter but constructor does not matter
	You can have multiple initialization blocks


SUPER-
	Whenever a child class constructor gets invoked it implicitly invokes the constructor of parent class. 
	You can also say that the compiler inserts a super(); 
	statement at the beginning of child class constructor.
	It can be used to only inside child class constructor.
	Super keyword can be used to invoke parent class variable, method, constructor.
	we cannot use both this and super keyword together in java constructor because this and super should be the first statement in any java constructor.

THIS-
	It is used to access current class constructor.
	It can be used inside another constructor of same class.
	It can be used to remove ambiguity error when we have data members and local are same name.
	Q:
	class Point {
	     int x;
	     int y;
	     void assign(int x, int y) {
	         x = this.x;
	         this.y = y;
	     }
	 
	     public String toString() {
	         return "Point(" + x + ", " + y + ")";
	     }
	}
	public class Test {
	     public static void main(String[] args) {
	         Point p1 = new Point();
	         p1.x = 10;
	         p1.y = 20;
	         Point p2 = new Point();
	         p2.assign(p1.x, p1.y);
	         System.out.println(p1.toString() + ";" + p2.toString());
	     }
	}
	Explanation
	HINT: First check if members are accessible or not. All the codes are in same file Test.java, and Point class & variable x, y are declared with default modifier hence these can be accessed within the same package. Class Test belongs to same package so no issues in accessing Point class and instance variables of Point class. Make use of pen and paper to draw the memory diagrams (heap and stack). It will be pretty quick to reach the result.
	
	Point p1 = new Point(); means p1.x = 0 and p1.y = 0 as instance variable are initialized to respective zeros. 
	p1.x = 10; means replace 0 with 10 in p1.x, 
	p1.y = 20; means replace 0 with 20 in p1.y, 
	
	Point p2 = new Point(); means p2.x = 0 and p2.y = 0 as instance variable are initialized to respective zeros. 
	p2.assign(p1.x, p1.y); invokes the assign method, parameter variable x = 10 and y = 20.
	As assign is invoked on p2 reference variable hence this and p2 refers to same Point object.
	x = this.x; means assign 0 to parameter variable x, no changes in this.y, which means p2.x is unchanged. 
	this.y = y; means assign 20 to this.y, which means p2.y is now 20
	So after assign method is invoked and control goes back to main method: p1.x = 10, p1.y = 20, p2.x = 0 and p2.y = 20. 
	Output is: Point(10, 20);Point(0, 20)


CONS OVERLOADING-
	Constructor overloading is a concept of having more than one constructor with different parameters list,
	in such a way so that each constructor performs a different task.
	Eg-  no-arg cons and arg 

PRIVATE CONSTRUCTOR-
	The use of private constructor is to serve singleton classes. 
	A singleton class is one which limits the number of objects creation to one. 
	Using private constructor we can ensure that no more than one object can be created at a time. 

STATIC CONSTRUCTOR-
	Not allowed in Java.
	Static variable /methods(cons is kind of a method) are associated with class and not the obj where as constructor is basically used to initialize the obj.


QUICK RECAP-

	Every class has a constructor whether it’s a normal class or an abstract class.
	
	Constructors are not methods and they don’t have any return type.
	
	Constructor can use any access specifier, 
	they can be declared as private also. 
	Private constructors are possible in java but there scope is within the class only.
	
	Like constructors method can also have name same as class name, 
	but still they have return type, though which we can identify them that they are methods not constructors.
	
	this() and super() should be the first statement in the constructor code.
	Constructor overloading is possible but overriding is not possible. 
	Which means we can have overloaded constructor in our class but we can’t override a constructor.
	Constructors can not be inherited.
	
	s do not have constructors.
	
	Abstract class can have constructor and it gets invoked when a class, 
	which implements , is instantiated. (i.e. object creation of concrete class).
	
	A constructor can also invoke another constructor of the same class – By using this(). 
	If you want to invoke a parameterized constructor then do it like this: this(parameter list).	

STATIC-
	The static keyword belongs to the class than an instance of the class.
	We can apply static keyword with variables, methods, blocks and nested classes.
	We use static keyword in java so that we can save our memory and make memory efficient.
	We can't call non-static data member in static member in java.
	We cannot use this and super in static context,  because this and super belongs to objects.
	because this and super belongs to objects.
	We can define static variable in abstract class.


STATIC VARIABLE-
	The static variable can be used to refer to the common property of all objects 
	(which is not unique for each object),
	for example, IFSC CODE, BANK NAME.
	The static variable gets memory only once in the class area at the time of class loading.
	Static var is a class var
	Static var can be accessed with the help of class name as well as obj ref
	eg.
	Bank b=new Bank();
	Bank.ifscCode=123 OR b.ifscCode=123 //both are same but the obj ref will give you a warning and also not a good habit to use.
	As Static var is a class var the var is created and initialized	not when an obj is instantiated but when the class is first loaded in JVM.
	
	Static Reference Variables and null:
		If the reference variable you are working with has a null value (meaning it is not referring to an object), it's in a dangerous state.  
		Specifically, if you access an instance member with it, you will see the dreaded "NullPointerException."  
		This is an exception created by the JVM and unless special exception handling code is written, will result in your program quitting prematurely.  
		
		For example, the following code will result in a NullPointerException:
		
		public static void main(String[] args) {
		    String s = null;
		    s = s.toUpperCase(); // Oops! s is null!
		}
		Static members are different.  While you shouldn't write sloppy/confusing code like this, 
		you should know (especially for the exam) that accessing static members with a null Class reference will not throw a NullPointerException.  
		For example, the java.lang.Math class has a static method called floor:
		
		public static void main(String[] args) {
		    Math m = null;
		    double result = m.floor(28.15); // Confusing code, but it works.
		}
		I want to stress, while the preceding code won't throw a NullPointerException, you shouldn't write code like that. It is much clearer to use the class name:
		
		public static void main(String[] args) {
		    double result = Math.floor(28.15);
		}
		See the "Exception Handling" section for more details on exceptions.
			

STATIC METHOD-
	A static method belongs to the class rather than the object of a class.
	No obj creation.Can be accessed using class name. /both are same but the obj ref will give you a warning and also not a good habit to use.
	A static method can access static data member and can change the value of it.
	Static method can be overloaded but cannot override
	 can have static methods	
	we can call super class static method in sub class but it can't override in sub class.
	Use?
	1. to update/fetch the class var data.
	2. provide the functionality without any need of an obj

	There are two main restrictions for the static method.

	1. The static method can not use non static data member or call non-static method directly.
	
	class A{  
 	int a=40;//non static  
	static int b=10;
   
 	public static void main(String args[]){  
  	a=20; //ILLEGAL(COMPILATION ERROR) AS WE DON'T FOR INSTANCE(OBJ) WE HAVE TO CHANGE THE VALUE OF a to 20 and rest unchagned
	b=20; //LEGAL as it will be changed for all the objs as b is static ie it belongs to the class
 	}  
	}  
	it
	
	2. this and super cannot be used in static context.(THIS AND SUPER REFERES TO AN OBJ)

	Why is the Java main method static?
	Ans) It is because the object is not required to call a static method. If it were a non-static method, 
	JVM creates an object first then call main() method that will lead the problem of extra memory allocation.
	Static methods cannot be overridden in Java, but if you declare the same static method in subclass then that would hide the method from its superclass. 
	So, if you call that method from subclass then the one in the subclass will get invoked
	 but if you call the same method from superclass then the one in superclass will be invoked. 
	This is known as method hiding in Java.

	Q:What is the result of the following code:
		public class Person {
		    String firstName;
		    static void setFirstName(String newValue) {
		        firstName = newValue;
		    }
		    public static void main(String[] args) {
		        Person p = new Person();
		        p.setFirstName("Jason");
		        System.out.println( "firstName: " + p.firstName );
		    }
		}
		Ans: Compilation error
		Static methods cannot access instance variable or methods. Plus, we really shouldn't call static methods with an object reference (p). 
		That, in itself isn't illegal, but it is considered poor coding.


	Q: True or False:  A static method can only be invoked after at least one object has been instantiated.
		Ans: False
		Static methods and variables are available as soon as the class has been loaded.


STATIC BLOCK-
	Is used to initialize the static data member. Cannot initialize non-static AS WE DON'T FOR INSTANCE(OBJ) WE HAVE TO CHANGE THE VALUE and keep rest unchagned
	cannot even call non-methods inside a static block as It is executed before the main method at the time of classloading
	so we don't know anything about initialization of the variables/parameters etc. So basically, we cannot call instance methods/variables froma static block 
	we can call statiic method tho as it is laoded at the time of class loading
	We can have Multiple static block in the code.

	public class Person {
		    {
		        personCount = 10;
		    }
		    static {
		        personCount = 20;
		    }
		    private static int personCount = 1000;
		    {
		        personCount = 30;
		    }
		    static {
		        personCount = 40;
		    }
		    public static void main(String[] args) {
		       System.out.println(Person.personCount); 
		       Person p = new Person();
		       System.out.println(Person.personCount);
		       Person.personCount = 100; 
		       p = new Person();
		       System.out.println(Person.personCount);
		    }
		}

OUTPUT:
40
30
30

EXPLANATION:
When the program starts and this main method is kicked off, the Person class is loaded.  
This, in turn, makes the static personCount variable available, with a default value of 0 (remember, all instance and static variables start with default values).

Next all of the static initialization blocks, and the static variable's explicit initialization are executed in the order they are listed, from top to bottom.  
Therefore, the personCount variable is set to 20, 1000, and finally 40.  So Line A prints "40."

On Line B, an object is instantiated, so that causes the instance initialization blocks to be executed in the order they are listed, from top to bottom.  
So now personCount is changed to 10 and finally 30.  Line C prints the value "30."

Line D changes the personCount to 100, but Line E causes the instance initialilzation blocks to be executed again.  
Therefore, the final value printed in Line F is, once again, "30."


STATIC CLASS-
	A class can be made static only if it is a nested class.

	Nested static class doesn’t need reference of Outer class
	A static class cannot access non-static members of the Outer class

STATIC CONSTRUCTOR-
	Not possible.

GARBAGE COLLECTOR:

The JRE manages the memory for you
You never have to destroy the obj explicitly or manage the memory it uses
The JRE deeletes the obj when it determines that they are no longer being used. This process is known as garbage collection
The JRE's garbage collector periodically searches memory for 'free'(unreferenced) obj that are no longer needed
When it finds one, it removes it from the heap
You can explicitly give a hint/suggesstion to the garbage collector by running the following command
System.gc();
This is just a suggesstion but we're not sure if the garbage collector will run for sure(might/might not)
eg.
Car myCar=new Car(1,"Suzuki");
myCar=new Car(2,"honda");
//Car(1,"Suzuki") is now eligible for gc as it is no longer referenced


Q:
class Pen {
     
}
 
public class TestPen {
     public static void main(String[] args) {
         new Pen(); //Line 1
         Pen p = new Pen(); // Line 2
         change(p); //Line 3
         System.out.println("About to end."); //Line 4
     }
 
     public static void change(Pen pen) { //Line 5
         pen = new Pen(); //Line 6
     }
}
Object created at Line 1 becomes eligible for Garbage collection after Line 1 only, as there are no references to it. So We have one object marked for GC. 
Object created at Line 6 becomes unreachable after change(Pen) method pops out of the STACK, and this happens after Line 3.
So at Line 4, we have two Pen objects eligible for Garbage collection: Created at Line 1 and Created at Line 6.

IF/ELSE-

	More on If/Else If/Else Statements
	More Examples
	In addition to using a boolean variable, a conditional statement may use a boolean literal, boolean operator, or a boolean return value from a method.  Here are some examples of these other forms:
	
		// boolean literal
		if( true ) {
		}
		// boolean operator (>= is 'greater than or equal to')
		if( myAge >= 40 ) {
		}
		// boolean return value from a method
		public boolean doSomething() { 
		    return true;
		}
		if( doSomething() ) {
		}
	Variable Scope
	Any variable that is declared in the conditional statement is local to that block. For example, the following would be illegal:
	
		int age = 40;
		if (age >= 25) {
		    // Note the "String" reference type.
		    // That means we're declaring the variable
		    // in this scope.
		    String message = "25 years or older.";
		}
		System.out.println(message); // ILLEGAL, message is out of scope

	If the variable is assigned inside the conditional, but is also to be used outside of it, make sure the variable is declared outside as well.  
	
		String message = null; // Declaration of "message"
		int age = 40;
		if (age >= 25) {
		    // Note that we've dropped the "String" reference type
		    // Which means we're referring to, rather than declaring
		    // the message variable
		    message = "25 years or older.";
		}
		System.out.println(message); // LEGAL
	Braces
	I mentioned that if a conditional doesn't use braces, only the first statement is considered a part of the conditional block (any subsequent statements are just normal statements, which will be executed every time).
	For example, due to the lack of braces, line A  below will be executed every time, even when the if block is evaluated to be false.
	
	if (age >= 25) 
	    message = "25 years or older.";
	    otherMessage = "More text..."; // LINE A
	
	
	... and the same goes for this example... even when age >= 25 (so the else block isn't entered), Line A is printed.
	
	
	
	if (age >= 25) 
	    message = "25 years or older.";
	else
	    message = "Younger than 25.";
	    otherMessage = "More text..."; // LINE A
	It should also be noted that when there is an else-if and/or else block, having multiple statements, without braces, in anything but the last block is illegal.
	
	For example, the following example is illegal:
	
	if (age >= 25) 
	    message = "25 years or older.";
	    otherMessage = "More text..."; // ILLEGAL
	else if (age >= 20) 
	    message = "Between 20 years and 24 years old";
	    otherMessage = "More text..."; // ILLEGAL
	else
	    message = "Younger than 20.";
	    otherMessage = "More text..."; // LEGAL
	Bottom line... USE YOUR BRACES! 


SWICTH STATEMENT- 
	int day = 4;
		switch (day) {
		  case 1:
		    System.out.println("Monday");
		    break;
		  case 2:
		    System.out.println("Tuesday");
		    break;
		  case 3:
		    System.out.println("Wednesday");
		    break;
		  case 4:
		    System.out.println("Thursday");
		    break;
		  case 5:
		    System.out.println("Friday");
		    break;
		  case 6:
		    System.out.println("Saturday");
		    break;
		  case 7:
		    System.out.println("Sunday");
		    break;
		}
		// Outputs "Thursday" (day 4)

	switch can hold fairly limited types of value ie int or those that can be converted to int implicitly
	int, byte,short,char,string(from java 7)

		eg.
		char c = 'A';
				switch (c) {
				  case 'A':
				    System.out.println("A");
				    break;
				  case 'B':
				    System.out.println("B");
				    break;
				  default:
				    System.out.println("C");


	More on Switch
	Break vs. Return
	In the "Introduction to Objects" section, I mentioned that it's OK to declare an empty return statement when a method returns void.  As a reminder, the following is odd (not really something you'd see in the "real world"), but legal:
	
	public void doSomething() {
	return;
	}
	Now that you've been introduced to conditional statements, you can see some "real world" example of how this might be used.  In these examples, if a condition is true, we don't want to do any additional processing so we return out of the method.  This is different than "break," which would only cause us to break out of a loop or switch statement (rather than the entire method). I will say, however, I'm not a big fan of having return statements in the middle of a method... Having multiple exit points can lead to hard to read, if not buggy, code.
	
	In any case, here are some legal examples of returning when the method's return type is void.
	
	public void doSomething() {
	if( isTrue ) {
	    return; // Exits the entire method
	}  else {
	    // Do some work...
	}
	//  Do some work if we didn't already return out of the method...
	}
	and...
	
	public void doSomething() {
	  switch (someVariable) {
	    case 0: {
	      return; // exits the entire method
	    }
	    case 1: {
	      // Do some work...
	      break; // exits the switch
	    }
	    case 2: {
	      // Do some work...
	      break; // exits the switch
	    }
	  }
	// If we didn't return out of the method 
	// do some more work...
	}
	Variable Scope
	Just like if / else if / else statements, any variables declared inside of a case are local to that code block.
	
	switch (someVariable) {
	  case 0: {
	  String msg = "Hello!"; // Declaration (rather than reference)
	  break;
	  }
	}
	System.out.println(msg); // ILLEGAL
	So make sure any variables you want to reference outside of the switch were also declared outside of the switch:
	
	String msg = null; // Declaration
	switch (someVariable) {
	  case 0: {
	  msg = "Hello!"; // Reference
	  break;
	  }
	}
	System.out.println(msg); // Legal
	Switch Content
	One final note: the only legal members of a switch statement are "case" and "default" statements.  For example, you can't have variables declared:
	
	switch (someVariable) {
	  String msg = "Hello"; // ILLEGAL
	  case 0: {
	  msg = "Hello!";
	  break;
	  }
	  default: {
	  msg = "Hey!";
	  break;
	  }
	}

	What will be the result of compiling and executing Test class?	
	package com.udayan.oca;
	 
	public class Test {
	     public static void main(String[] args) {
	         String fruit = "mango";
	         switch (fruit) {
	             default:
	                 System.out.println("ANY FRUIT WILL DO");
	             case "Apple":
	                 System.out.println("APPLE");
	             case "Mango":
	                 System.out.println("MANGO");
	             case "Banana":
	                 System.out.println("BANANA");
	                 break;
	         }
	     }
	}
	Explanation
	"mango" is different from "Mango", so there is no matching case available. default block is executed, "ANY FRUIT WILL DO" is printed on to the screen.
	No break statement inside default, hence control enters in fall-through and executes remaining blocks until the break; is found or switch block ends.
	So in this case, it prints APPLE, MANGO, BANANA one after another and break; statement takes control out of switch block. main method ends and program terminates successfully.

JAVA OPERATORS-

	15	()		Parentheses
		[]		Array subscript
		·		Member selection		Left to Right	
				
					
	14	++		Unary post-increment
		--		Unary post-decrement		Right to left
	
	
									
	13	++		Unary pre-increment
		--		Unary pre-decrement
		+		Unary plus
		-		Unary minus
		!		Unary logical negation
		~		Unary bitwise complement
		(type)		Unary type cast			Right to left
	
	
	12	*		Multiplication
		/		Division
		%		Modulus				Left to right
	
	
	11	+		Addition
		-		Subtraction			Left to right
	
	
	10	<<		Bitwise left shift
		>>		Bitwise right shift 
				with sign extension
		>>>		Bitwise right shift 
				with zero extension		Left to right
	
	
	9	<		Relational less than
		<=		Relational less than or equal
		>		Relational greater than
		>=		Relational greater than or equal
		instanceof	Type comparison 
				(objects only)			Left to right
	
	8	==		Relational is equal to
		!=		Relational is not equal to	Left to right
	
		
	7	&		Bitwise AND			Left to right
	
	6	^		Bitwise exclusive OR		Left to right
	
	5	|		Bitwise inclusive OR		Left to right
	
	4	&&		Logical AND			Left to right
	
	3	||		Logical OR			Left to right
	
	2	? :		Ternary conditional		Right to left
	
	1	=		Assignment
		+=		Addition assignment
		-=		Subtraction assignment
		*=		Multiplication assignment
		/=		Division assignment
		%=		Modulus assignment		Right to left



	NOTE: (Inside the if statement)
		& <-- verifies both operands
		&& <-- stops evaluating if the first operand evaluates to false since the result will be false

		exprA | exprB <-- this means evaluate exprA then evaluate exprB then do the |.
		exprA || exprB <-- this means evaluate exprA and only if this is false then evaluate exprB and do the ||.

	Shifts:
	Refer: https://www.javatpoint.com/operator-shifting

	Post increment-	
	int y=0;
	sysout(y++) //0 (y++ ---> old value=0, new value=1, returns=old value)


	int y=0;
	y++;
	sysout(y) //1 (y++ ---> old value=0, new value=1, returns=old value but that old value is not used anywhere nor assigned to any var)

	
	int y=0;
	y=y++;
	sysout(y) //1 (y++ ---> old value=0, new value=1, returns=old value but that old value is assigned to y so y becomes 0 )


	More Operator Examples
	Boolean Operators
	These operators, which return true or false, were mentioned in the Operators Part 1 lecture, but let's go over a few more examples.  To start, each of the examples will use the following variables:
	
	boolean courseInSession = true;
	int lectureCount = 150;
	! is the "logical complement" operator.  It allows us to test for a false value:
	
	if( !courseInSession ) {
	System.out.println("Course is not in session.");
	}
	 ... or it can flip a true value to false, and a false value to true:
	
	courseInSession = !courseInSession;
	!= is the "not equal to" operator:
	
	if( lectureCount != 150 ) {
	   System.out.println("The lecture count is something other than 150");
	}
	The == operator checks for equality:
	
	if( lectureCount == 150 ) {
	   System.out.println("The lecture count is 150");
	}
	And the rest check to see if a value is less than (<), less than or equal to (<=), greater than (>), greater than or equal to (>=):
	
	if( lectureCount < 10 ) {
	  System.out.println("Lecture count is less than 10");
	} else if( lectureCount >= 20 && lectureCount <= 30 ) {
	  System.out.println("Lecture count is between 20 and 30 [inclusive]");
	} else if( lectureCount > 100 ) {
	  System.out.println("Lecture count is 101 or greater.");
	}
	
	
	Arithmetic Operators
	+ is add (or concatenation when used with a String), - is subtract, * is multiply, and / is divide. The use of those operators should be obvious. The one arithmetic operator that deserves further discussion is the modulo or remainder operator: %.  This operator returns the remainder of a division operation.  For example:
	
	10 % 2 == 0 (10 / 2 == 5 with a remainder of 0)
	
	10 % 4 == 2 (10 / 4 == 2 with a remainder of 2)
	
	etc.
	
	
	
	Assignment Operators
	= is an assignment operator.  It can be used on its own (int x = 30;) or it can be used with arithmetic operations as well:
	
	x = x + 5; 
	
	is the same thing as:
	
	x += 5;
	
	Other examples:
	
	x -= 5; // Same as x = x - 5;
	
	x *= 5; // Same as x = x * 5;
	
	X /= 5; // Same as x = x / 5;
	
	x %= 5; // Same as x = x % 5;

What will be the result of compiling and executing the Test class?

package com.udayan.oca;
 
public class Test {
     public static void main(String[] args) {
         int grade = 60;
         if(grade = 60)
             System.out.println("You passed...");
         else
             System.out.println("You failed...");
     }
}
Explanation
Following are allowed in boolean expression of if statement:
1. Any expression whose result is either true or false. e.g. age > 20 
2. A boolean variable. e.g. flag 
3. A boolean literal: true or false 
4. A boolean assignment. e.g. flag = true 
boolean expression in this case is: (grade = 60), which is an int assignment and not boolean assignment. Hence Compilation error.

Q:
package com.udayan.oca;
import java.time.LocalTime;
public class Test {
     public static void main(String[] args) {
         LocalTime time = LocalTime.of(16, 40);
         String amPm = time.getHour() >= 12 ? (time.getHour() == 12) ? "PM" : "AM";
         System.out.println(amPm);
     }
}
Explanation
This question is on ternary operator (?:). If an expression has multiple ternary operators then number of ? and : should match.
Given expression contains 2 ? and 1 : and hence Compilation Error.

Q:
public class Test {
     public static void main(String[] args) {
         System.out.println("Output is: " + 10 != 5);
     }
}
Explanation
Binary plus (+) has got higher precedence than != operator. Let us group the expression. 
"Output is: " + 10 != 5 
= ("Output is: " + 10) != 5 
[!= is binary operator, so we have to evaluate the left side first. + operator behaves as concatenation operator.] 
= "Output is: 10" != 5 
Left side of above expression is String, and right side is int. But String can't be compared to int, hence compilation error. 

Q:
For the class Test, which options, if used to replace /*INSERT*/, will print "Lucky no. 7" on to the console? Select 3 options.

package com.udayan.oca;
 
public class Test {
     public static void main(String[] args) {
         /*INSERT*/
         switch(var) {
             case 7:
                 System.out.println("Lucky no. 7");
                 break;
             default:
                 System.out.println("DEFAULT");
         }
     }
}
Explanation
switch can accept primitive types: byte, short, int, char; wrapper types: Byte, Short, Integer, Character; String and enums.
In this case, all are valid values but only 3 executes "case 7:". case is comparing integer value 7.
NOTE: character seven, '7' is different from integer value seven, 7. So "char var = '7';" and "Character var = '7';" will print DEFAULT on to the console.

Q:
public class Test {
     public static void main(String[] args) {
         byte var = 100;
         switch(var) {
             case 100:
                 System.out.println("var is 100");
                 break;
             case 200:
                 System.out.println("var is 200");
                 break;
             default:
                 System.out.println("In default");
         }
     }
}
Explanation
case values must evaluate to the same type / compatible type as the switch expression can use. 
switch expression can accept following: 
char or Character 
byte or Byte 
short or Short 
int or Integer 
An enum only from Java 6 
A String expression only from Java 7 
In this case, switch expression [switch (var)] is of byte type.
byte range is from -128 to 127. But in case expression [case 200], 200 is outside byte range and hence compilation error.

public class Test {
    char var1;
    double var2;
    float var3;
	
    public static void main(String[] args) {
        Test obj = new Test();
        System.out.println(">" + obj.var1);
        System.out.println(">" + obj.var2);
        System.out.println(">" + obj.var3);
    }
}
Explanation
Primitive type instance variables are initialized to respective zeros (byte: 0, short: 0, int: 0, long: 0L, float: 0.0f, double: 0.0, boolean: false, char: \u0000).
When printed on the console; byte, short, int & long prints 0, float & double print 0.0, boolean prints false and char prints nothing or non-printable character (whitespace). 
Reference type instance variables are initialized to null.

	Q:
	public class Test {
	     public static void main(String[] args) {
	         Double [] arr = new Double[2];
	         System.out.println(arr[0] + arr[1]);
	     }
	}
	Explanation
	Array elements are initialized to their default values. arr is referring to an array of Double type, which is reference type and hence both the array elements are initialized to null.
	To calculate arr[0] + arr[1], java runtime converts the expression to arr[0].doubleValue() + arr[1].doubleValue(). As arr[0] and arr[1] are null hence calling doubleValue() method throws NullPointerException.


LOOPS-
	Loops are of 3 types basically
	for loop, while  loop, do while loop

	while(true){
	  int z=0;
	  while(true){
	    if(z>10)
	      break;
	    sysout(z)
	  }
	}// this will print 0to9 infinite times

	to end the outer loop we use LABELS

	outer_label:	
	while(true){
	  int z=0;
	  while(true){
	    if(z>10)
	      break outer_label;
	    sysout(z)
	  }
	}// this will print 0to9 1 time

	1>
	package com.udayan.oca; 
	public class Test {
	     public static void main(String[] args) {
	         do {
	             System.out.println(100);
	         } while (false);
	         System.out.println("Bye");
	     }
	}
	Explanation
	As do-while loop executes at least once, hence none of the code is unreachable in this case. 
	Java runtime prints 100 to the console, then it checks boolean expression, which is false. 
	Hence control goes out of do-while block. Java runtime executes 2nd System.out.println statement to print "Bye" on to the console.
	
	2>
	package com.udayan.oca;
	public class Test {
	     public static void main(String[] args) {
	         int [] arr = {2, 1, 0};
	         for(int i : arr) {
	             System.out.println(arr[i]);
	         }
	     }
	}
	Explanation
	Inside enhanced for loop, System.out.println(arr[i]); is used instead of System.out.println(i); 
	When loop executes 1st time, i stores the first array element, which is 2 but System.out.println statement prints arr[2] which is 0. 
	Loop executes in this manner and prints 0 1 2 on to the console.
	

ARRAYS-

	1> 
	package com.udayan.oca;
	public class Test {
	    public static void main(String[] args) {
	        /*INSERT*/
	        arr[1] = 5;
	        arr[2] = 10;
	        System.out.println("[" + arr[1] + ", " + arr[2] + "]"); //Line n1
	    }
	}
	And below statements:
	1. short arr [] = new short[2];
	2. byte [] arr = new byte[10];
	3. short [] arr; arr = new short[3];
	4. short [2] arr;
	5. short [3] arr;
	6. int [] arr = new int[]{100, 100};
	7. int [] arr = new int[]{0, 0, 0, 0};
	8. short [] arr = {};
	9. short [] arr = new short[2]{5, 10};
	How many above statements can be used to replace /*INSERT*/, such that on execution, code will print [5, 10] on to the console?
	
	Explanation
	Let's check all the statements one by one:
	
	1. short arr [] = new short[2]; => ✗
	You can declare one-dimensional array by using either "short arr []" or "short [] arr". 'arr' refers to a short array object of 2 elements. arr[2] will throw ArrayIndexOutOfBoundsException at runtime.
	
	2. byte [] arr = new byte[10]; => ✓
	'arr' refers to a byte array object of 10 elements, where 0 is assigned to each array element. But later on element at 1st and 2nd indexes have been re-initialized. Line n1 successfully prints [5, 10] on to the console.
	
	3. short [] arr; arr = new short[3]; => ✓
	You can create an array object in the same statement or next statement. 'arr' refers to a short array object of 3 elements, where 0 is assigned to each array element. Later on element at 1st and 2nd indexes have been re-initialized. Line n1 successfully prints [5, 10] on to the console.
	
	4. short [2] arr; ✗
	Array size cannot be specified at the time of declaration, so short [2] arr; causes compilation error. 
	
	5. short [3] arr; ✗
	Array size cannot be specified at the time of declaration, so short [3] arr; causes compilation error.
	
	6. int [] arr = new int[]{100, 100}; => ✗
	'arr' refers to an int array object of size 2 and both array elements have value 100. arr[2] will throw ArrayIndexOutOfBoundsException at runtime.
	
	7. int [] arr = new int[]{0, 0, 0, 0}; => ✓
	'arr' refers to an int array object of size 4 and all array elements have value 0. Later on element at 1st and 2nd indexes have been re-initialized. Line n1 successfully prints [5, 10] on to the console.
	
	8. short [] arr = {}; => ✗
	'arr' refers to a short array object of 0 size. so arr[1] will throw ArrayIndexOutOfBoundsException at runtime.
	
	9. short [] arr = new short[2]{5, 10}; => ✗
	
	Array's size can't be specified, if you use {} to assign values to array elements.
	Hence, out of the given 9 statements, only 3 will print [5, 10] on to the console.
	
	2>
	What will be the result of compiling and executing Test class?
	package com.udayan.oca;
	public class Test {
	     public static void main(String[] args) {
	         double [] arr = new int[2]; //Line 3
	         System.out.println(arr[0]); //Line 4
	     }
	}
	int variable can easily be assigned to double type but double [] and int [] are not compatible. 
	In fact, both are siblings and can't be assigned to each other, so Line 3 causes compilation failure.
	
	3>
	package com.udayan.oca;
	 
	public class Test {
	    public static void main(String[] args) {
	        String [] arr = {"I", "N", "S", "E", "R", "T"};
	        for(/*INSERT*/) {
	            if (n % 2 == 0) {
	                continue;
	            }
	            System.out.print(arr[n]); //Line n1
	        }
	    }
	}
	
	
	And below options:
	
	1. int n = 0; n < arr.length; n += 1
	2. int n = 0; n <= arr.length; n += 1
	3. int n = 1; n < arr.length; n += 2
	4. int n = 1; n <= arr.length; n += 2
	
	How many above options can be used to replace /*INSERT*/, such that on execution, code will print NET on to the console?
	Explanation
	From the given array, if you print the elements at 1st, 3rd and 5th indexes, then you will get expected output.
	Also note that, for values of n = 0, 2, 4, 6; Line n1 would not be executed, which means even if the value of n is 6, 
	above code will not throw ArrayIndexOutOfBoundsException.
	
	For 1st option [int n = 0; n < arr.length; n += 1], values of n used: 0, 1, 2, 3, 4, 5 and because of continue; statement, 
	Line n1 will not execute for 0, 2 & 4 and it will execute only for 1, 3 & 5 and therefore NET will be printed.
	
	For 2nd option [int n = 0; n <= arr.length; n += 1], values of n used: 0, 1, 2, 3, 4, 5, 6 and because of continue; 
	statement, Line n1 will not execute for 0, 2, 4 & 6 and it will execute only for 1, 3 & 5 and therefore NET will be printed.
	
	For 3rd option [int n = 1; n < arr.length; n += 2], values of n used: 1, 3, 5 and therefore NET will be printed.
	
	For 4th option [int n = 1; n <= arr.length; n += 2], values of n used: 1, 3, 5 and therefore NET will be printed.
	
	Hence, all the 4 options are valid.

INHERITANCE-
	The process by which one class acquires the properties(data members) and functionalities(methods) of another class is called inheritance. 
	The aim of inheritance is to provide the reusability of code 
	so that a class has to write only the unique features and rest of the common properties can be extended from the another class.
	Parent class cannot access the child class members.

	When we declare the same method in child class which is already present in the parent class then this is called method overriding. 
	In this case when we call the method from child class object, the child class version of the method is called. 
	However we can call the parent class method using super keyword.
	The extends always precedes the implements keyword in any Java class declaration.
	
	Single Inheritance: refers to a child and parent class relationship where a class extends the another class.

	Multilevel inheritance: refers to a child and parent class relationship where a class extends the child class. 
	For example class C extends class B and class B extends class A.

	Hierarchical inheritance: refers to a child and parent class relationship where more than one classes extends the same class. 
	For example, classes B, C & D extends the same class A.
	
	Multiple Inheritance: refers to the concept of one class extending more than one classes, which means a child class has two parent classes. 
	For example class C extends both classes A and B. 
	Java doesn’t support multiple inheritance.

	Hybrid inheritance: Combination of more than one types of inheritance in a single program. 
	For example class A & B extends class C and another class D extends class A 
	then this is a hybrid inheritance example because it is a combination of single and hierarchical inheritance. 
	Since multiple inheritance is not possible in java, Hybrid is also not possible.
	1>
	//A.java
	package com.udayan.oca;
	 
	public class A {
	     public void print() {
	         System.out.println("A");
	     }
	}
	
	
	//B.java
	package com.udayan.oca;
	 
	public class B extends A {
	     public void print() {
	         System.out.println("B");
	     }
	}
	
	//Test.java
	package com.udayan.oca.test;
	 
	import com.udayan.oca.*;
	 
	public class Test {
	     public static void main(String[] args) {
	         A obj1 = new A();
	         B obj2 = (B)obj1;
	         obj2.print();
	     }
	}
	Class A and B are declared public and inside same package com.udayan.oca. Method print() of class A has correctly been overridden by B.
	
	print() method is public so no issues in accessing it anywhere.
	
	
	
	Let's check the code inside main method.
	
	A obj1 = new A(); => obj1 refers to an instance of class A.
	
	B obj2 = (B)obj1; => obj1 is of type A and it is assigned to obj2 (B type), hence explicit casting is necessary. 
	obj1 refers to an instance of class A, so at runtime obj2 will also refer to an instance of class A. 
	sub type (B obj2) can't refer to an object of super type (obj1) so at runtime B obj2 = (B)obj1; will throw ClassCastException.
	
	
	2>
	//A.java
	package com.udayan.oca;
	 
	public class A {
	     public int i1 = 1;
	     protected int i2 = 2;
	}
	
	
	//B.java
	package com.udayan.oca.test;
 
	import com.udayan.oca.A;
	 
	public class B extends A {
	     public void print() {
	         A obj = new A();
	         System.out.println(obj.i1); //Line 8
	         System.out.println(obj.i2); //Line 9
	         System.out.println(this.i2); //Line 10
	         System.out.println(super.i2); //Line 11
	     }
	 
	     public static void main(String [] args) {
	         new B().print();
	     }
	}
	Variable i1 is declared public in class A, so Line 8 doesn't cause any compilation error. 
	Variable i2 is declared protected so it can only be accessed in subclass using inheritance(can be accessed anywhere in class B) but not using object reference variable. 
	obj.i2 causes compilation failure.
	class B inherits variable i2 from class A, so inside class B it can be accessed by using either this or super. Line 10 and Line 11 don't cause any compilation error.
	
	Which of these access modifiers can be used for a top level interface?
	Explanation
	A top level interface can be declared with either public or default modifiers.
	public interface is accessible across all packages but interface declared with default modifier and be accessed in the defining package only.
	
	3>
	
	Consider code below:

	package com.udayan.oca;
	 
	class PenDrive {
	    int capacity;
	    PenDrive(int capacity) {
	        this.capacity = capacity;
	    }
	}
	 
	class OTG extends PenDrive {
	    String type;
	    String make; 
	    OTG(int capacity, String type) {
	        /*INSERT-1*/
	    }
	    OTG(String make) {
	        /*INSERT-2*/
	        this.make = make;
	    }
	}
	 
	public class Test {
	    public static void main(String[] args) {
	        OTG obj = new OTG(128, "TYPE-C");
	        System.out.println(obj.capacity + ":" + obj.type);
	    }
	}
	Currently above code causes compilation error.
	
	Which of the options can successfully print 128:TYPE-C on to the console?

	Explanation
	Java compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available. 
	Compiler adds super(); as the first line in OTG's constructor: OTG(int capacity, String type) { super(); } but PenDrive class doesn't have a no-arg constructor and that is why OTG's constructor causes compilation error.
	For the same reason, OTG(String make) constructor also causes compilation error.
	To correct these compilation errors, parent class constructor should be invoked by using super(int); This would resolve compilation error.
	Remember: Constructor call using this(...) or super(...) must be the first statement inside the constructor.
	
	In the main(String[]) method, OTG(int, String) constructor is invoked, which means, we OTG(String) constructor will not be executed. So, to solve the complilation error in OTG(String) constructor, super(0); or super(128); both will work and these will not affect the expected output.
	
	We have to make changes in OTG(int, String) constructor such that on execution, output is 128:TYPE-C.
	super(capacity); will only assign value to capacity property, to assign value to type another statement is needed.
	this.type = type; must be the 2nd statement.
	So, /*INSERT-1*/ must be replaced with:
	super(capacity);
	this.type = type;

	4>
	//Test.java
	package com.udayan.oca.test; 
	abstract class Animal {
	     private String name;
	 
	     Animal(String name) {
	        this.name = name;
	     }
	 
	     public String getName() {
	         return name;
	     }
	}
	class Dog extends Animal {
	     private String breed;
	     Dog(String breed) {
	         this.breed = breed;
	     }
	     Dog(String name, String breed) {
	         super(name);
	         this.breed = breed;
	     }
	     public String getBreed() {
	         return breed;
	     }
	}
	 
	public class Test {
	     public static void main(String[] args) {
	         Dog dog1 = new Dog("Beagle");
	         Dog dog2 = new Dog("Bubbly", "Poodle");
	         System.out.println(dog1.getName() + ":" + dog1.getBreed() + ":" + 
	                             dog2.getName() + ":" + dog2.getBreed());
	     }
	}
	Explanation
	abstract class can have constructors and it also possible to have abstract class without any abstract method. So, there is no issue with Animal class.
	Java compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available. 
	Inside Animal class Constructor, compiler adds super(); => Animal(String name) { super(); this.name = name; }, super() in this case invokes the no-arg constructor of Object class and hence no compilation error here. 
	Compiler changes Dog(String) constructor to: Dog(String breed) { super(); this.breed = breed; }. No-arg constructor is not available in Animal class and as another constructor is provided, java compiler doesn't add default constructor. Hence Dog(String) constructor gives compilation error.
	There is no issue with Dog(String, String) constructor.


	5>
	interface Printable {
	     public void setMargin();
	     public void setOrientation();
	}
	 
	abstract class Paper implements Printable { //Line 7
	     public void setMargin() {}
	     //Line 9
	}
	 
	class NewsPaper extends Paper { //Line 12
	     public void setMargin() {}
	     //Line 14
	}
	Above code is currently giving compilation error. Which 2 modifications, done independently, enable the code to compile?
	Explanation
	First you should find out the reason for compilation error. Methods declared in Printable interface are implicitly abstract, no issues with Printable interface.
	class Paper is declared abstract and it implements Printable interface, it overrides setMargin() method but setOrientation() method is still abstract. No issues with class Paper as it is an abstract class and can have 0 or more abstract methods. 
	class NewsPaper is concrete class and it extends Paper class (which is abstract). So class NewsPaper must override setOrientation() method OR it must be declared abstract.
	Replacing Line 9 with 'public abstract void setOrientation();' is not necessary and it will not resolve the compilation error in NewsPaper class.
	Replacing Line 7 with 'class Paper implements Printable {' will cause compilation failure of Paper class as it inherits abstract method 'setOrientation'.

POLYMORPHISM-
	Single task can be done in different way.
	"one name many forms"

	Compile time polymorphism:
	it is nothing but the method overloading in java. 
	In simple terms we can say that a class can have more than one methods with same name but with different number of arguments
	or different types of arguments or both.
	
	Runtime polymorphism:
	Runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time.

METHOD OVERLOADING-
	Method Overloading is a feature that allows a class to have more than one method having the same name, 
	if their argument lists are different.
	Used to update the features of the parent class.

	Method Signature:
	a) Method name

	b) Number of arguments

	c) Types of arguments

	Overloaded methods can be either static or non static
.
	Overloaded methods can be synchronized.

	we can overload main() method. 
	A class can have any number of main() methods 
	but execution starts from public static void main(String[] args) only.
	
	we can declare overloaded methods as final.

	Overloading is the best example for static binding.
	
	we can override a method which is overloaded in super class.
	
METHOD OVERRIDDING-
	Method overriding is another way to define method with same name but different code but it must be in sub class.
	
	Modifying a super class method in the sub class is called method overriding. Using method overriding, 
	we can change super class method according to the requirements of sub class.
	
	Used to update the features of the parent class.
	
	Private methods cannot be overridden as it is not visible outside of the class.
	Static method cannot be overridden
	Constructors cannot be overridden
	You must not reduce the visibility of a method while overriding.
	You can’t override non-static methods as static.

ABSTRACTION-
	To show functionality and hide complexity or internal details or hide implementation details to the user is known as abstraction in java.
	
	There are two ways in java we can achieve abstraction:

	By using abstract class (0 to 100%).
	By using  (100%).
	 

ABSTRACT METHOD-

	An abstract method is a method without body. You just declare method, without defining it and use abstract keyword in method declaration
		
Abstract class may or may not have abstract methods. can declare and define static methods.
No obj creation of abstract class. To access the non-abstract method of an abstract class, use child class obj.
	Cannot be private
	Cannot be static.
	Cannot be final.
	Abstract classes can be nested.
	abstract methods can not be declared as synchronized.
	abstract class can declare and define a constructor in Java.

	ABSTRACT CLASS VS INTERFACE

	Main difference is methods of a Java interface are implicitly abstract and cannot have implementations. 
	A Java abstract class can have instance methods that implements a default behavior.

	Variables declared in a Java interface is by default final. An  abstract class may contain non-final variables.

	Members of a Java interface are public by default. 
	A Java abstract class can have the usual flavors of class members like private, protected, etc..
	
	Java interface should be implemented using keyword “implements”; A Java abstract class should be extended using keyword “extends”.

	In comparison with java abstract classes, java interfaces are slow as it requires extra indirection.



ENCAPSULATION-
	Binding the data into a single unit.
	Encapsulation is an object oriented concept which is used to hide the internal details of a class.
	In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class.
	
	To achieve encapsulation in Java −

	Declare the variables of a class as private.

	Provide public setter and getter methods to modify and view the variables values.

	Abstraction solves the problem at design level while encapsulation solves the problem at implementation level.	

	*>
	class Message {
	    String msg = "Happy New Year!";
	    
	    public void print() {
	        System.out.println(msg);
	    }
	}
	public class Test {
	    public static void change(Message m) { //Line n5
	        m = new Message(); //Line n6
	        m.msg = "Happy Holidays!"; //Line n7
	    }  
	    public static void main(String[] args) {
	        Message obj = new Message(); //Line n1
	        obj.print(); //Line n2
	        change(obj); //Line n3
	        obj.print(); //Line n4
	    }
	}
	Explanation
	It is pass-by-reference scheme.
	Initially, msg = "Happy New Year!"
	Call to method change(Message) doesn't modify the msg property of passed object rather it creates another Message object and modifies the msg property of new object to "Happy Holidays!"
	So, the instance of Message referred by obj remains unchanged.
	Hence in the output, you get:
	Happy New Year!
	Happy New Year!
	
	*>
	public class Test {
	     public static void main(String[] args) {
	         short [] args = new short[]{50, 50};
	         args[0] = 5;
	         args[1] = 10;
	         System.out.println("[" + args[0] + ", " + args[1] + "]");
	     }
	}
	Explanation
	main method's parameter variable name is "args" and it is a local to main method.
	So, same name "args" can't be used directly within the curly brackets of main method.
	short [] args = new short[]{50, 50}; gives compilation error for using same name for local variable.
	
	What will be the result of compiling and executing Test class?
	public class Test {
	     public static void main(String[] args) {
	         short [] args = new short[]{50, 50};
	         args[0] = 5;
	         args[1] = 10;
	         System.out.println("[" + args[0] + ", " + args[1] + "]");
	     }
	}
	Explanation
	main method's parameter variable name is "args" and it is a local to main method.
	So, same name "args" can't be used directly within the curly brackets of main method.
	short [] args = new short[]{50, 50}; gives compilation error for using same name for local variable.
	
	Question: 
	What will be the result of compiling and executing Test class?
	public class Test {
	     public static void main(String[] args) {
	         double price = 90000;
	         String model;
	         if(price > 100000) {
	             model = "Tesla Model X";
	         } else if(price <= 100000) {
	             model = "Tesla Model S";
	         }
	           System.out.println(model);
	     }
	}
	Explanation
	In this case "if - else if" block is used and not "if - else" block.
	90000 is assigned to variable 'price' but you can assign parameter value or call some method returning double value, such as:
	'double price = currentTemp();'.
	In these cases compiler will not know the exact value until runtime, hence Java Compiler is not sure which boolean expression will be evaluated to true and so variable model may not be initialized.
	Usage of LOCAL variable, 'model' without initialization gives compilation error. Hence, System.out.println(model); gives compilation error.
	
	Question: 
	What will be the result of compiling and executing Test class?
	public class Test {
	     private static void m(int x) {
	         System.out.println("int version");
	     }
	 
	     private static void m(char x) {
	         System.out.println("char version");
	     }
	 
	     public static void main(String [] args) {
	         int i = '5';
	         m(i);
	         m('5');
	     }
	}
	Explanation
	Method m is overloaded. Which overloaded method to invoke is decided at compile time. m(i) is tagged to m(int) as i is of int type and m('5') is tagged to m(char) as '5' is char literal.
	
	Question:
	What will be the result of compiling and executing Test class?
	public class Test {
	     public static void main(String[] args) {
	         int x = 1;
	         while(checkAndIncrement(x)) {
	             System.out.println(x);
	         }
	     }
	 
	     private static boolean checkAndIncrement(int x) {
	         if(x < 5) {
	             x++;
	             return true;
	         } else {
	             return false;
	         }
	     }
	}
	Explanation
	x of checkAndIncrement method contains the copy of variable x defined in main method. So, changes done to x in checkAndIncrement method are not reflected in the variable x of main. x of main remains 1 as code inside main is not changing its value.
	Every time checkAndIncrement method is invoked with argument value 1, so true is returned always and hence while loop executes indefinitely. 
	
	Question: 
	What will be the result of compiling and executing Test class?
	
	//Test.java
	class Student {
	     String name;
	     int marks;
	 
	     Student(String name, int marks) {
	         this.name = name;
	         this.marks = marks;
	     }
	}
	 
	public class Test {
	     public static void main(String[] args) {
	         Student student = new Student("James", 25);
	         int marks = 25;
	         review(student, marks);
	         System.out.println(marks + "-" + student.marks);
	     }
	 
	     private static void review(Student stud, int marks) {
	         marks = marks + 10;
	         stud.marks+=marks;
	     }
	}
	Explanation
	In below statements: student<main> means student inside main method.
	On execution of main method: student<main> --> {"James", 25}, marks<main> = 25.
	On execution of review method: stud<review> --> {"James", 25} (same object referred by student<main>), marks<review> = 25 (this marks is different from the marks defined in main method). marks<review> = 35 and stud.marks = 60. So at the end of review method: stud<review> --> {"James", 60}, marks<review> = 35.
	Control goes back to main method: student<main> --> {"James", 60}, marks<main> = 25. Changes done to reference variable are visible in main method but changes done to primitive variable are not reflected in main method.
	
	Question: 
	Consider the code of Test.java file: 
	class Student {
	     String name;
	     int age; 
	     void Student() {
	         Student("James", 25);
	     }
	     void Student(String name, int age) {
	         this.name = name;
	         this.age = age;
	     }
	}
	public class Test {
	     public static void main(String[] args) {
	         Student s = new Student();
	         System.out.println(s.name + ":" + s.age);
	     }
	}
	What will be the result of compiling and executing Test class?
	Explanation
	Methods can have same name as the class. Student() and Student(String, int) are methods and not constructors of the class, note the void return type of these methods.
	As no constructors are provided in the Student class, java compiler adds default no-arg constructor. That is why the statement Student s = new Student(); doesn't give any compilation error.
	Default values are assigned to instance variables, hence null is assigned to name and 0 is assigned to age. 
	In the output, null:0 is displayed.
	
	Question:
	Consider the following class:
	
	package com.udayan.oca;
	 
	public class Employee {
	     public int passportNo; //line 2
	}
	Which of the following is the correct way to make the variable 'passportNo' read only for any other class?
	Explanation
	'passportNo' should be read-only for any other class.
	This means make 'passportNo' private and provide public getter method. Don't provide public setter as then 'passportNo' will be read-write property.
	If passportNo is declared with default scope, then other classes in the same package will be able to access passportNo for read-write operation.
	
	Question: 
	____________ uses access modifiers to protect variables and hide them within a class.
	
	Which of the following options accurately fill in the blanks above?
	Explanation
	Encapsulation is all about having private instance variable and providing public getter and setter methods.

INTERFACE-
	Yes, unlike classes, an interface can extend more than one interface in Java. 
	There are several example of this behavior in JDK itself
	e.g. java.util.List interface extends both Collection and Iterable interface to tell that it is a Collection as well as it allows iteration via Iterator.
	Interface can only contain methods that are public and are on and only one of the following: abstract, default and static
	If you don't add public modifier,it is added implicitly
	Also if neither abstract,defult or static is set, it is by default static
	in addition, interfaces can only have var that are public, static and final. they are implied so no need to add explicitly
	The class that implements the interface should define all the methods of the interface else will get compilation error
	If the class that implements the interface is a abstract class itself it may/may not define the methods of the interface 
	but the next class which extends this abstract class has to define all abstract as well as interface methods
	interface extends interfance class implements interface and we can implement any number of interfaces unlike class extends only 1 class

	In an interface we can define a method(JAVA8) by using a default/static keyword
	USING DEFAULT
	public default void  draw(){
	    ...
	}
	public class Rect implements Drawable{
		public void tesDraw(){
		    draw(); //LEGAL
		}	
	 }

	USING STATIC (will follow all the rules of a static method. concrete classes do not inherit static methods like they do default methods. All static methods calls must be done through interface itself)
	public interface Drwabable{
	public static void  draw(){
	    ...
	}
	}
	public class Rect implements Drawable{
		public void tesDraw(){
		    draw(); //ILLEGAL
		    Rect.draw(); //ILLEGAL
		    Drawable.draw(); //LEGAL
		}	
	 }
	Methods with default modifier should only appear in interafaces. They are not legal in abstract or concrete classes
	WHY JAVA8 introduced this update?
	It gives us an opportunity to introduce new methods, without breaking  classes that are already implementing the interface 

	Drawback of default implemenetation
	It does not have any acess to the instance variable and that is because it's a method that has access to only what's available inside the interface

	While an IDE or a compiler will complain if you make this mistake, you won't have these tools when taking the exam.  So remember: all interface methods are public, even if they don't use the public keyword.
	Therefore given the following legal interface:
	
	public interface Payable {
	    double pay();
	}
	Unlike interface methods, concrete implementations MUST include the public modifier.  Therefore, the following code will not compile because pay() is missing the "public" modifier. 
	
	public class Consultant implements Payable {
	    double pay() {
	        return 80_000.0;
	    }
	}
	The correct code is:	
	public class Consultant implements Payable {
	    public double pay() {
	        return 80_000.0;
	    }
	}

	Interface that does not contain any method is known as Marker interface
	eg. public interface Serializable {
	}
	USE: A marker interface is typically used by the JRE to determine an obj adheres to some rule or is able to perform some action etc
	for eg. the class that implements java.io.Serializable informs the JRE that obj of this type may be serialized(a term that means the obj's state maybe turned into a byte array which could be saved as a file, passed over network etc)

	Interface that contains one and only one abstract method is known as Functional interface	
	eg. public interface Payable {
	double raiseSalary(double percentage);
	}
	Even if the interface contains multiple static or default methods, it is sstill considered 'functional' if it is limited to 1 abstract method
	NOTE: 	The single exception to the "only one abstract method" rule is if the additional abstract methods are overriding ones declared in java.lang.Object

FINAL-
	In Java, all non-static methods are by default virtual functions. 
	Methods that are marked with the keyword final are non-virtual.

STRING-  

	String is a class and not a primitive data type.
	Immutable and final.
	JVM uses string pool to store all string objects.
String class does not have an inbuilt string function to reverse.
	StringBuilder, StringBuffer has reverse() method (to check palindrome).
	String a=new String(“abc”);
	String a=”abc”;
	When we use new operator, JVM creates the string obj but don’t store it into the string pool 
But we can use intern() method to store the obj into string pool or return reference if there is already a string with equal value present in the pool.
Strings are immutable, so we can’t change it’s value in program. Hence it’s thread-safe and can be safely used in multi-threaded environment.
METHOD THAT WILL REMOVE GIVEN CHAR FROM STRING.
We can use replaceAll method to replace all the occurance of a String with another String. The important point to note is that it accepts String as argument, so we will use Character class to create String and use it to replace all the characters with empty String.

private static String removeChar(String str, char c) 
{ 
if (str == null) 
return null; 
return str.replaceAll(Character.toString(c), ""); 
}

We can use String class toUpperCase and toLowerCase methods to get the String in all upper case or lower case.



Java String subSequence
Java 1.4 introduced the CharSequence interface and String implements this interface. This is the only reason for the implementation of subSequence() method in String class. Internally it invokes the substring() method.

public CharSequence subSequence(int beginIndex, int endIndex) { return this.substring(beginIndex, endIndex); }



Java String implements Comparable interface and it has two variants of compareTo() methods.
compareTo(String anotherString) method compares the String object with the String argument passed lexicographically. If String object precedes the argument passed, it returns negative integer and if String object follows the argument String passed, it returns a positive integer. It returns zero when both the String have the same value, in this case equals(String str) method will also return true.
compareToIgnoreCase(String str): This method is similar to the first one, except that it ignores the case. It uses String CASE_INSENSITIVE_ORDER Comparator for case insensitive comparison. If the value is zero then equalsIgnoreCase(String str) will also return true.
We can use String getBytes() method to convert String to byte array and we can use String constructor new String(byte[] arr) to convert byte array to String.
Can we use String in switch case?
This is a tricky question used to check your knowledge of current Java developments. Java 7 extended the capability of switch case to use Strings also, earlier Java versions don’t support this.
If you are implementing conditional flow for Strings, you can use if-else conditions and you can use switch case if you are using Java 7 or higher versions.
	

We can use split(String regex) to split the String into String array based on the provided regular expression

Q:
//Test.java
package com.udayan.oca;
 
public class Test {
    public static void main(String[] args) {
        String s1 = "OCAJP";
        String s2 = "OCAJP" + "";
        System.out.println(s1 == s2);
    }
}
Explanation
Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.



For the statement, String s2 = "OCAJP" + "";, `"OCAJP" + ""` is a constant expression as both the operands "OCAJP" and "" are String literals, which means the expression `"OCAJP" + ""` is computed at compile-time and results in String literal "OCAJP".

So, during compilation, Java compiler translates the statement

String s2 = "OCAJP" + "";

to

String s2 = "OCAJP";

As "OCAJP" is a String literal, hence at runtime it will be referred by String Pool.



When Test class is executed,

s1 refers to "OCAJP" (String Pool object).

s2 also refers to same String pool object "OCAJP".

s1 and s2 both refer to the same String object and that is why s1 == s2 returns true.



Please note that Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.

For below code snippet:

String s1 = "OCAJP";
String s2 = s1 + "";
System.out.println(s1 == s2);
Output is false, as s1 is a variable and `s1 + ""` is not a constant expression, therefore this expression is computed only at runtime and a new non-pool String object is created.
package com.udayan.oca;
 
public class Test {
     public static void main(String[] args) {
         String str1 = new String("Core");
         String str2 = new String("CoRe");
         System.out.println(str1 = str2);
     }
}
Explanation
System.out.println(str1 = str2) has assignment(=) operator and not equality(==) operator.

After the assignment, str1 refers to "CoRe" and System.out.println prints "CoRe" to the console.

public class Test {
     public static void main(String[] args) {
         String str = "java";
         StringBuilder sb = new StringBuilder("java");
 
         System.out.println(str.equals(sb) + ":" + sb.equals(str));
     }
}
Explanation
equals method declared in Object class has the declaration: public boolean equals(Object). Generally, equals method is used to compare different instances of same class 
but if you pass any other object, there is no compilation error. Parameter type is Object so it can accept any Java object


Q:
package com.udayan.oca;
 
public class Test {
     public static void main(String[] args) {
         StringBuilder sb = new StringBuilder("Java");
         String s1 = sb.toString();
         String s2 = sb.toString();
 
         System.out.println(s1 == s2);
     }
}
Explanation
toString() method defined in StringBuilder class doesn't use String literal rather uses the constructor of String class to create the instance of String class.
So both s1 and s2 refer to different String instances even though their contents are same. s1 == s2 returns false.

COLLECTION FRAMEWORK-
	

	The Collection in Java is a framework that provides an architecture to store and manipulate the group of objects.
	
	Java Collections can achieve all the operations that you perform on a data such as searching, sorting, insertion, manipulation, and deletion.
	
		Java Collection means a single unit of objects. 
		Java Collection framework provides many interfaces (Set, List, Queue, Deque) 
		and classes (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet).	
	
	
		
		What are the two ways to iterate the elements of a collection?
		ANS- ITERATOR INTERFACE,FOREACH LLOP,LISTITERATOR INTERFACE,FORLOOP.
	
	
		What is the difference between ArrayList and LinkedList classes in collection framework?
		ANS 		ARRAY LIST			LINKED LIST
			INTERNALLY USES DYNAMIC ARR	INTERNALLY USES DOUBLY LINKEDLIST
			
			MANIPULATION IS SLOW		MANIPULATON IS FAST
		
			CAN ACT AS A LIST		CAN ACT AS LIST AND QUEUE
							AS IT IMPLEMENTS LIST AND DEQUEUE INTERFACE
	
			BETTER FOR STORING DATA		BETTER FOR MANIPULATING DATA
	
		
		What is the difference between ArrayList and Vector classes in collection framework?
	
				ARRAY LIST					VECTOR
	
			NOT SYNCRONIZED					SYNCRONIZED
			
			Increments 50% of current			increments 100% of current
			size if total no of elements exceeds		ie doubles arraysize if total no of
			from its capacity				elements exceeds the capacity
	
			Not legacy class(introduced in JDK1.2)		It is a legacy class
	
			Fast(Not syncronized)				Slow(Syncronized)
	
			Uses Iterator interface to traverse		Uses Iterator or Enumeration interface to traverse
	
	
		What is the difference between HashSet and HashMap classes in collection framework?
	
				HASH SET					HASH MAP
	
			Implements Set Interface			Implements Map interface
	
			store objects(elements or values)		storing key & value pairs.
	
			HashSet does not allow duplicate elements	HashMap does not allow duplicate keys 
									however it allows to have duplicate values
	
	permits to have a single null value.		 permits single null key and any   number of null values.
	
	
		What is the difference between HashMap and Hashtable class?
	
		
	
			
	What is the difference between Iterator and Enumeration interface in collection framework?
		
		
	
	How can we sort the elements of an object? What is the difference between Comparable and Comparator interfaces?
	ANS- public void sort(List list)
		
	
	What is the difference between Java collection and Java collections?


ARRAYLIST-

public class Test {
     public static void main(String[] args) {
         List<Character> list = new ArrayList<>();
         list.add(0, 'V');
         list.add('T');
         list.add(1, 'E');
         list.add(3, 'O');
 
         if(list.contains('O')) {
             list.remove('O');
         }
 
         for(char ch : list) {
             System.out.print(ch);
         }
     }
}
Explanation
list.add(0, 'V'); => char 'V' is converted to Character object and stored as the first element in the list. list --> [V]. 

list.add('T'); => char 'T' is auto-boxed to Character object and stored at the end of the list. list --> [V,T]. 

list.add(1, 'E'); => char 'E' is auto-boxed to Character object and inserted at index 1 of the list, this shifts T to the right. list --> [V,E,T]. 

list.add(3, 'O'); => char 'O' is auto-boxed to Character object and added at index 3 of the list. list --> [V,E,T,O].

list.contains('O') => char 'O' is auto-boxed to Character object and as Character class overrides equals(String) method this expression returns true. Control goes inside if-block and executes: list.remove('O');.



remove method is overloaded: remove(int) and remove(Object). char can be easily assigned to int so compiler tags remove(int) method. list.remove(<ASCCI value of 'O'>); ASCCI value of 'A' is 65 (this everybody knows) so ASCII value of 'O' will be more than 65.



list.remove('O') throws runtime exception, as it tries to remove an item from the index greater than 65 but allowed index is 0 to 3 only.
class Counter {
     int count;
     Counter(int count) {
         this.count = count;
     }
 
     public String toString() {
         return "Counter-" + count;
     }
}
 
public class Test {
     public static void main(String[] args) {
         ArrayList<Counter> original = new ArrayList<>();
         original.add(new Counter(10));
 
         ArrayList<Counter> cloned = (ArrayList<Counter>) original.clone();
         cloned.get(0).count = 5;
 
         System.out.println(original);
     }
}
Let's see what is happening during execution:

main(String [] args) method goes on to the top of the STACK.

1. ArrayList<Counter> original = new ArrayList<>(); => It creates an ArrayList object [suppose at memory location 15EE00] and variable 'original' refers to it.

2. original.add(new Counter(10)); => It creates a Counter object [suppose at memory location 25AF06] and adds it as a first element of the ArrayList. This means element at 0th index of the ArrayList instance refers to Counter object at the memory location 25AF06.

3. ArrayList<Counter> cloned = (ArrayList<Counter>) original.clone(); => original.clone() creates a new array list object, [suppose at memory location 45BA12] and then it will copy the contents of the ArrayList object stored at [15EE00]. So, cloned contains memory address of the same Counter object.

In this case, original != cloned, but original.get(0) == cloned.get(0). This means both the array lists are created at different memory location but refer to same Counter object. 

4. cloned.get(0).count = 5; => cloned.get(0) returns the Counter object stored at the memory location 25AF06 and .count = 5 means change the value of count variable of the Counter object (stored at memory location 25AF06) to 5. 

5. System.out.println(original); Prints the element of ArrayList original, which is: {25AF06} and toString() method prints: [Counter-5] as Counter object referred by [25AF06] is [Counter object (5)].
	public static void main(String[] args) {
	ArrayList<Integer> points = new ArrayList<>();
	points.add(1);
	points.add(2);
	points.add(3);
	points.add(4);
	points.add(null);
	points.remove(1);
	points.remove(null);
	System.out.println(points);
	}
	
	List can print null values as well
	here the op is [1,3,4] because the number 1 is added in the second line of the list, but the list indexes from 0, 
	so the 1 is in position zero and the removal done in line 7 removes the data in position 1 of the list which is 2. 
	Remembering that you cannot give the NullPointer exception because lists can print null if it is inserted in one of the positions of the list, 
	it would only give NullPointer exception if the list was empty


public class Test {
     public static void main(String[] args) {
         List<Integer> list = new ArrayList<>();
         list.add(100);
         list.add(200);
         list.add(100);
         list.add(200);
         list.remove(100);
 
         System.out.println(list);
     }
}
Explanation
List cannot accept primitives, it can accept objects only. So, when 100 and 200 are added to the list, then auto-boxing feature converts these to wrapper objects of Integer type.
So, 4 items gets added to the list. One can expect the same behavior with remove method as well that 100 will be auto-boxed to Integer object.
But remove method is overloaded in List interface: remove(int) => Removes the element from the specified position in this list
and remove(Object)  => Removes the first occurrence of the specified element from the list.
As remove(int) version is available, which perfectly matches with the call remove(100); hence compiler does not do auto-boxing in this case.
But at runtime remove(100) tries to remove the element at 100th index and this throws IndexOutOfBoundsException.

Q:
package com.udayan.oca;
 
import java.util.ArrayList;
import java.util.List;
 
public class Test {
     public static void main(String [] args) {
         List<Integer> list = new ArrayList<Integer>();
         list.add(new Integer(2));
         list.add(new Integer(1));
         list.add(new Integer(0));
 
         list.remove(list.indexOf(0));
 
         System.out.println(list);
     }
}
Explanation
remove method of List interface is overloaded: remove(int) and remove(Object).
indexOf method accepts argument of Object type, in this case list.indexOf(0) => 0 is auto-boxed to Integer object so no issues with indexOf code. list.indexOf(0) returns 2 (index at which 0 is stored in the list). So list.remove(list.indexOf(0)); is converted to list.remove(2);
remove(int) version is matched, it's a direct match so compiler doesn't do auto-boxing in this case. list.remove(2) removes the element at index 2, which is 0. 
Hence in the output, you get [2, 1].

//Test.java
package com.udayan.oca;
 
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
 
public class Test {
     public static void main(String[] args) {
         List<String> dryFruits = new ArrayList<>();
         dryFruits.add("Walnut");
         dryFruits.add("Apricot");
         dryFruits.add("Almond");
         dryFruits.add("Date");
 
         Iterator<String> iterator = dryFruits.iterator();
         while(iterator.hasNext()) {
             String dryFruit = iterator.next();
             if(dryFruit.startsWith("A")) {
                 dryFruits.remove(dryFruit);
             }
         }
        
         System.out.println(dryFruits);
    }
}
Explanation
ConcurrentModificationException exception may be thrown for following condition:
1. Collection is being iterated using Iterator/ListIterator or by using for-each loop.
And
2. Execution of Iterator.next(), Iterator.remove(), ListIterator.previous(), ListIterator.set(E) & ListIterator.add(E) methods. These methods may throw java.util.ConcurrentModificationException in case Collection had been modified by means other than the iterator itself, such as Collection.add(E) or Collection.remove(Object) or List.remove(int) etc.
For the given code, 'dryFruits' list is being iterated using the Iterator<String>.

hasNext() method of Iterator has following implementation:

public boolean hasNext() {
    return cursor != size;
}
Where cursor is the index of next element to return and initially it is 0.
1st Iteration: cursor = 0, size = 4, hasNext() returns true. iterator.next() increments the cursor by 1 and returns "Walnut".
2nd Iteration: cursor = 1, size = 4, hasNext() returns true. iterator.next() increments the cursor by 1 and returns "Apricot". As "Apricot" starts with "A", hence dryFruits.remove(dryFruit) removes "Apricot" from the list and hence reducing the list's size by 1, size becomes 3.
3rd Iteration: cursor = 2, size = 3, hasNext() returns true. iterator.next() method throws java.util.ConcurrentModificationException.
If you want to remove the items from ArrayList, while using Iterator or ListIterator, then use Iterator.remove() or ListIterator.remove() method and NOT List.remove(...) method. Using List.remove(...) method while iterating the list (using the Iterator/ListIterator or for-each) may throw java.util.ConcurrentModificationException.

import java.util.ArrayList;
import java.util.List;
 
public class Test {
     public static void main(String[] args) {
         List<String> list1 = new ArrayList<>();
         list1.add("A");
         list1.add("D");
 
         List<String> list2 = new ArrayList<>();
         list2.add("B");
         list2.add("C");
 
         list1.addAll(1, list2);
 
         System.out.println(list1);
     }
}
Explanation
list1 --> [A, D], 
list2 --> [B, C], 
list1.addAll(1, list2); is almost equal to list1.add(1, [B, C]); => Inserts B at index 1, C takes index 2 and D is moved to index 3. list1 --> [A, B, C, D]

POJO-
	
	WHY OVERRIDE METHODS IN POJO:
		When you're creating simple Java classes (POJOs), it's a good idea to override a few special methods:
		1. `equals()`: Decide how two objects of your class should be considered equal.
		2. `hashCode()`: Create a unique number for each object, important for certain data structures.
		3. `toString()`: Provide a nice human-readable description of your object.
		These overrides help your classes work better with collections, comparisons, and debugging.
	
	What is a POJO class?
	   Answer: A POJO (Plain Old Java Object) class is a Java class that adheres to basic Java principles without relying on any specific frameworks or libraries. It typically has private fields, public getters and setters, and may optionally override certain methods for better functionality.
	
	Why would you use a POJO class?
	   Answer: POJOs are used to keep the code simple and maintainable. They help encapsulate data and behavior within objects, making it easier to manage and understand the code. POJOs are also useful for data transfer between layers of an application or when interacting with external systems.
	
	What are the key requirements for a class to be considered a POJO?
	   Answer: The key requirements for a class to be considered a POJO are:
	   - The class should have private fields.
	   - It should provide public getter and setter methods for each field (if needed).
	   - It may optionally override methods like `equals`, `hashCode`, and `toString`.
	
	Why is it important to override the `equals`, `hashCode`, and `toString` methods in a POJO class?
	   Answer: These methods affect how instances of a class behave in various contexts: 
	   - `equals`: Determines object equality.
	   - `hashCode`: Ensures consistent behavior in hash-based collections.
	   - `toString`: Provides a human-readable representation of the object.
	
	What is the purpose of the `toString` method in a POJO class?**
	   Answer: The `toString` method provides a user-friendly representation of the object's state. It's useful for debugging, logging, and generating informative output.
	
	Can you give an example of a situation where you might use a POJO class?**
	    Answer: You might use a POJO class to represent a `Person` entity in a database, with fields like name, age, and address, along with getters, setters, and potentially overridden methods.
	
	Apart from `equals`, `hashCode`, and `toString`, are there any other methods you might consider overriding in a POJO class?**
	    Answer: Depending on the situation, you might consider overriding `compareTo` for implementing the `Comparable` interface if you need to compare instances of the class.
	
	What is the role of JavaBeans conventions in POJOs?**
	    Answer: JavaBeans conventions provide guidelines for creating reusable components by adhering to naming and design patterns. POJOs often follow these conventions, which promote consistent and maintainable code.
	
	Can a POJO class extend another class or implement interfaces?**
	    Answer:** Yes, a POJO class can extend another class and implement interfaces. However, you should ensure that the class remains simple and doesn't become tightly coupled with complex inheritance hierarchies.


DATE-
//Test.java
package com.udayan.oca;
 
import java.time.LocalDate;
 
class MyLocalDate extends LocalDate {
     @Override
     public String toString() {
         return super.getDayOfMonth() + "-" + super.getMonthValue() + 
            "-" +  super.getYear();
     }
}
 
public class Test {
     public static void main(String [] args) {
         MyLocalDate date = LocalDate.parse("1980-03-16");
         System.out.println(date);
     }
}
Explanation
LocalDate is a final class so cannot be extended.


//Test.java
package com.udayan.oca;
 
import java.time.LocalDate;
import java.time.LocalTime;
 
public class Test {
     public static void main(String [] args) {
         LocalDate date = LocalDate.parse("1947-08-14");
         LocalTime time = LocalTime.MAX;
         System.out.println(date.atTime(time));
     }
}
LocalTime.MIN --> {00:00}, LocalTime.MAX --> {23:59:59.999999999}, LocalTime.MIDNIGHT --> {00:00}, LocalTime.NOON --> {12:00}. 
date.atTime(LocalTime) method creates a LocalDateTime instance by combining date and time parts.
toString() method of LocalDateTime class prints the date and time parts separated by T in upper case.

//Test.java
package com.udayan.oca;
 
import java.time.LocalDate;
import java.time.Period;
import java.time.format.DateTimeFormatter;
 
public class Test {
     public static void main(String [] args) {
         LocalDate date = LocalDate.of(2012, 1, 11);
         Period period = Period.ofMonths(2);
         DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM-dd-yy");
         System.out.print(formatter.format(date.minus(period)));
     }
}
Explanation
date --> {2012-01-11}, period --> {P2M}, date.minus(period) --> {2011-11-11} [subtract 2 months period from {2012-01-11}, month is changed to 11 and year is changed to 2011].
formatter -> {MM-dd-yy}, when date {2011-11-11} is formatter in this format 11-11-11 is printed on to the console.

import java.time.LocalDate;
 
public class Test {
     public static void main(String [] args) {
          LocalDate date = LocalDate.of(2020, 9, 31);
          System.out.println(date);
     }
}
Explanation
LocalDate.of(...) method first validates year, then month and finally day of the month. 
September can't have 31 days so LocalDate.of(...) method throws an instance of java.time.DateTimeException class.

LAMBDA EXPRESSION-
	A lambda expression is a syntax used to pass a block of code into a method that accepts a functional interface parameter
	Rather than creating an entire classthat implements the functional interface, the developer is able to simply pass in an implementation of the interface's sole method
	TRADITIONAL WAY:
	public interface Payable {
	    double raiseSalary(double percentage);
	}
 	//cutCheck methods accepts Payable as a parameter
	public void cutCheck(Payable p)
	{
	  double updatedSalary=p.reaiseSalary(.04);
	}
	//A consultant class implements Payable interface
	public class Consultant implements Payable
	{
		private double salary=80_000.00;
		public double raiseSalary(double percentage)
		{
			return salary+(salary*percentgae);
		}
	}
	// then cutCheck is passed a Consultant instance as a Payable argument
	Consultant uxEngineer= new Consultant();
	cutcheck(uxEngineer);

	In order to make a new raiseSalary implementation, we'll need to create a new class to define it again
	lambda expression allows us to pass in  the funtional interface method implementation , without the need to create an entire class of it.

	USING LAMBDA:
	double salary=80_000;
	cutCheck( (double percentage) -> {	return salary+ (percentage*salary);	} );
	Here,
	(double percentage) = Method parameters
	-> = Seperator
	{	return salary+ (percentage*salary)	} = Method Body
	

	For multiple parameters
	(String a, String b, String c)-> {	return a+b+c;	}
	for no parameter
	()-> {	return "Hello";	}


	LETS SIMPLIFY THIS
	(double percentage) -> {	return salary+ (percentage*salary);	} 

	They parameter type is optional
	(percentage) -> {	return salary+ (percentage*salary);	} 

	If there is only 1 parameter, and the parameter type has been omitted, the paranthhesis that surround the parameter is optional
	percentage -> {	return salary+ (percentage*salary);	} 

	If there is only 1 statement in the body , the curly braces, return keyword and semiclono are optional.
	However, they all eist as a group;either they all appear together or all are omitted
	percentage -> salary+ (percentage*salary) 
	cutCheck( percentage -> salary+ (percentage*salary) );
	Although in the above expression we have kept the parameters same but change it
	x -> salary+(x*salary) //Legal implementation of the raiseSalary method in payable

	PREDICATE:
	Java includes a functional interface called "Predicate" to handle very common scenario: a "test" method is invoked with a parameter resulting in a boolean output.
	From my understanding predicate is just a lambda expression wi=hich is going to return a boolean value
	// Java program to illustrate Simple Predicate

	import java.util.function.Predicate;
	public class PredicateInterfaceExample1 {
		public static void main(String[] args)
		{
			Predicate<Integer> p = i -> (i < 18);
			System.out.println(p.test(10));
		}
	}

Q:
class Employee {
     private String name;
     private int age;
     private double salary;
 
     public Employee(String name, int age, double salary) {
         this.name = name;
         this.age = age;
         this.salary = salary;
     }
 
     public String getName() {
         return name;
     }
 
    public int getAge() {
         return age;
     }
 
    public double getSalary() {
         return salary;
     }
 
    public String toString() {
         return name;
     }
}
 
public class Test {
     public static void main(String [] args) {
         List<Employee> list = new ArrayList<>();
         list.add(new Employee("James", 25, 15000));
         list.add(new Employee("Lucy", 23, 12000));
         list.add(new Employee("Bill", 27, 10000));
         list.add(new Employee("Jack", 19, 5000));
         list.add(new Employee("Liya", 20, 8000));
 
         process(list, /*INSERT*/);
 
         System.out.println(list);
     }
 
     private static void process(List<Employee> list, Predicate<Employee> predicate) {
         Iterator<Employee> iterator = list.iterator();
         while(iterator.hasNext()) {
             if(predicate.test(iterator.next()))
             iterator.remove();
         }
      }
}
Which of the following lambda expressions, if used to replace /*INSERT*/, prints [Jack, Liya] on to the console?

Select 2 options.






Explanation
Jack's salary is 5000 and Liya's salary is 8000. If Employee's salary is >= 10000 then that Employee object is removed from the list.



Allowed lambda expression is: 

(Employee e) -> { return e.getSalary() >= 10000; }, 

Can be simplified to:  (e) -> { return e.getSalary() >= 10000; } => type can be removed from left side of the expression. 

Further simplified to: e -> { return e.getSalary() >= 10000; } => if there is only one parameter in left part, then round brackets (parenthesis) can be removed. 

Further simplified to: e -> e.getSalary() >= 10000 => if there is only one statement in the right side then semicolon inside the body, curly brackets and return statement can be removed. But all 3 [return, {}, ;] must be removed together.



NOTE: there should not be any space between - and > of arrow operator.
STATIC IMPORTS-
	We usually define constants as static final in java
	ALong with abstract, static and default methods, interfaces can also define constants
	Static import is import constants without important the entire class
	Eg.
	public interface SafeDriver {
	public static final int MAXIMUM_SPEED=55;
	public static final int SAFE_FOLLOWING_DISTANCE=100;
	public static final double MINIMUM_FUEL_LEVEL=0.25;

	public static void printMaxSpeed(){
	  sysout(MAXIMUM_SPEED);//static var can be used inside a static/non-static block but non-static(instance var) cannot be used in static method as static belongs to class and instance var might chnage value for every obj created.
	}
	public void drive();
	public void stop();
	}

	import static com.sush.SafeDriver.printMaxSpeed;
	public class Test{
	psvm(){
	printMaxSpeed();
	}
	}

	we can also do
	import static com.sush.SafeDriver.*;
	For wildcard,
	int speed = MAXIMUM_SPEED; //LEGAL
	printMaxSpeed(); //LEGAL
	double distance= SafeDriver.SAFE_FOLLOWING_DISTANCE; //ILLEGAL even if this is the proper way to call static var/methods ie className.varName/className.methodName

	So to make this legal
	import com.sush.SafeDriver;// remove static from imports and treat it as traditional imports as we do for static/non static methods/classes
	...
	double distance= SafeDriver.SAFE_FOLLOWING_DISTANCE;

	


	
	
	


MULTITHREADING-
	Multithreading in Java is a process of executing multiple threads simultaneously.
	A thread is a lightweight sub-process, the smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking.
	However, we use multithreading than multiprocessing because threads use a shared memory area. They don't allocate separate memory area so saves memory, and context-switching between the threads takes less time than process.
	    Java Multithreading is mostly used in games, animation, etc.	
	
	Multitasking
	Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved in two ways:
	oProcess-based Multitasking (Multiprocessing)
	oThread-based Multitasking (Multithreading)
	1) Process-based Multitasking (Multiprocessing)
	oEach process has an address in memory. In other words, each process allocates a separate memory area.
	oA process is heavyweight.
	oCost of communication between the process is high.
	oSwitching from one process to another requires some time for saving and loading registers, memory maps, updating lists, etc.
	2) Thread-based Multitasking (Multithreading)
	oThreads share the same address space.
	oA thread is lightweight.
	oCost of communication between the thread is low.
	What is Thread in java
	A thread is a lightweight subprocess, the smallest unit of processing. It is a separate path of execution.
	Threads are independent. If there occurs exception in one thread, it doesn't affect other threads. It uses a shared memory area.
	NOTE: At a time one thread is executed only.
	Thread class extends Object class and implements Runnable interface.
	
	oHow to perform multithreading by anonymous class?
	opublic class AnonymousThreadTest {
	o   public static void main(String[] args) {
	o      new Thread() {
	o         public void run() {
	o            for (int i=1; i <= 5; i++) {
	o               System.out.println("run() method: " + i);
	o            }
	o         }
	o      }.start();
	o      for (int j=1; j <= 5; j++) {
	o         System.out.println("main() method: " + j);
	o      }
	o   }
	o}
	
	oWhat happens if we start a thread twice?
	After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown. In such case, thread will run once but for second time, it will throw exception.
	
	o	What happens if we call the run() method instead of start() method?
	Can we call run() method directly to start a new thread. No, you can not directly call run method to start a thread. You need to call start method to create a new thread. If you call run method directly , it won't create a new thread and it will be in same stack as main
	oWhat is the purpose of join method?
	The join() method waits for a thread to die. In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task.
	
	oWhat is the shutdown hook?
	Shutdown Hooks are a special construct that allows developers to plug in a piece of code to be executed when the JVM is shutting down.
	
	
	Life cycle of a Thread (Thread States)
	A thread can be in one of the five states. According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state.
	But for better understanding the threads, we are explaining it in the 5 states.
	The life cycle of the thread in java is controlled by JVM.
	
	
	1) New
	The thread is in new state if you create an instance of Thread class but before the invocation of start() method.
	2) Runnable
	The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread.
	3) Running
	The thread is in running state if the thread scheduler has selected it.
	4) Non-Runnable (Blocked)
	This is the state when the thread is still alive, but is currently not eligible to run.
	5) Terminated
	A thread is in terminated or dead state when its run() method exits.
	How to create thread
	There are two ways to create a thread:
	1.By extending Thread class
	2.By implementing Runnable interface.

	Thread class:
	Thread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface.
	Commonly used Constructors of Thread class:
	oThread()
	oThread(String name)
	oThread(Runnable r)
	oThread(Runnable r,String name)
	
	
	Runnable interface:
	The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run().
	1.public void run(): is used to perform action for a thread.
	
	Starting a thread:
	start() method of Thread class is used to start a newly created thread. It performs following tasks:
	oA new thread starts(with new callstack).
	oThe thread moves from New state to the Runnable state.
	oWhen the thread gets a chance to execute, its target run() method will run.
	
	
	1) Java Thread Example by extending Thread class
	1.class Multi extends Thread{  
	2.public void run(){  
	3.System.out.println("thread is running...");  
	4.}  
	5.public static void main(String args[]){  
	6.Multi t1=new Multi();  
	7.t1.start();  
	8. }  
	9.}  
	Output:thread is running...
	
	2) Java Thread Example by implementing Runnable interface
	1.class Multi3 implements Runnable{  
	2.public void run(){  
	3.System.out.println("thread is running...");  
	4.}  
	5.  
	6.public static void main(String args[]){  
	7.Multi3 m1=new Multi3();  
	8.Thread t1 =new Thread(m1);  
	9.t1.start();  
	10. }  
	11.}  
	Output:thread is running...
	If you are not extending the Thread class,your class object would not be treated as a thread object.So you need to explicitely create Thread class object.We are passing the object of your class that implements Runnable so that your class run() method may execute.
	
	Thread Scheduler in Java
	Thread scheduler in java is the part of the JVM that decides which thread should run.
		The thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads.
	
	Difference between preemptive scheduling and time slicing
	Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.
	Sleep method in java
	The sleep() method of Thread class is used to sleep a thread for the specified amount of time
	 Daemon Thread in Java
	Daemon thread in java is a service provider thread that provides services to the user thread. Its life depend on the mercy of user threads i.e. when all the user threads dies, JVM terminates this thread automatically.
	There are many java daemon threads running automatically e.g. gc, finalizer etc.
	It is a low priority thread.
	No.	Method	Description
	1)	public void setDaemon(boolean status)	is used to mark the current thread as daemon thread or user thread.
	2)	public boolean isDaemon()	is used to check that current is daemon.
	Java Thread Pool
	Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times.
	In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again.
	
	Multithreading Interview Questions
	1) What is multithreading?
	Multithreading is a process of executing multiple threads simultaneously. Multithreading is used to obtain the multitasking. It consumes less memory and gives the fast and efficient performance. Its main advantages are:
	oThreads share the same address space.
	oThe thread is lightweight.
	oThe cost of communication between the processes is low.
	More details.
	
	2) What is the thread?
	A thread is a lightweight subprocess. It is a separate path of execution because each thread runs in a different stack frame. A process may contain multiple threads. Threads share the process resources, but still, they execute independently.
	More details.
	
	3) Differentiate between process and thread?
	There are the following differences between the process and thread.
	oA Program in the execution is called the process whereas; A thread is a subset of the process
	oProcesses are independent whereas threads are the subset of process.
	oProcess have different address space in memory, while threads contain a shared address space.
	oContext switching is faster between the threads as compared to processes.
	oInter-process communication is slower and expensive than inter-thread communication.
	oAny change in Parent process doesn't affect the child process whereas changes in parent thread can affect the child thread.
	
	
	4) What do you understand by inter-thread communication?
	oThe process of communication between synchronized threads is termed as inter-thread communication.
	oInter-thread communication is used to avoid thread polling in Java.
	oThe thread is paused running in its critical section, and another thread is allowed to enter (or lock) in the same critical section to be executed.
	oIt can be obtained by wait(), notify(), and notifyAll() methods.
	
	5) What is the purpose of wait() method in Java?
	The wait() method is provided by the Object class in Java. This method is used for inter-thread communication in Java. The java.lang.Object.wait() is used to pause the current thread, and wait until another thread does not call the notify() or notifyAll() method. Its syntax is given below.
	public final void wait()
	
	6) Why must wait() method be called from the synchronized block?
	We must call the wait method otherwise it will throw java.lang.IllegalMonitorStateException exception. Moreover, we need wait() method for inter-thread communication with notify() and notifyAll(). Therefore It must be present in the synchronized block for the proper and correct communication.
	
	7) What are the advantages of multithreading?
	Multithreading programming has the following advantages:
	oMultithreading allows an application/program to be always reactive for input, even already running with some background tasks
	oMultithreading allows the faster execution of tasks, as threads execute independently.
	oMultithreading provides better utilization of cache memory as threads share the common memory resources.
	oMultithreading reduces the number of the required server as one server can execute multiple threads at a time.
	
	8) What are the states in the lifecycle of a Thread?
	A thread can have one of the following states during its lifetime:
	1.New: In this state, a Thread class object is created using a new operator, but the thread is not alive. Thread doesn't start until we call the start() method.
	2.Runnable: In this state, the thread is ready to run after calling the start() method. However, the thread is not yet selected by the thread scheduler.
	3.Running: In this state, the thread scheduler picks the thread from the ready state, and the thread is running.
	4.Waiting/Blocked: In this state, a thread is not running but still alive, or it is waiting for the other thread to finish.
	5.Dead/Terminated: A thread is in terminated or dead state when the run() method exits.
	
	
	9) What is the difference between preemptive scheduling and time slicing?
	Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.
	
	10) What is context switching?
	In Context switching the state of the process (or thread) is stored so that it can be restored and execution can be resumed from the same point later. Context switching enables the multiple processes to share the same CPU.
	
	11) Differentiate between the Thread class and Runnable interface for creating a Thread?
	The Thread can be created by using two ways.
	oBy extending the Thread class
	oBy implementing the Thread class
	However, the primary differences between both the ways are given below:
	oBy extending the Thread class, we cannot extend any other class, as Java does not allow multiple inheritances while implementing the Runnable interface; we can also extend other base class(if required).
	oBy extending the Thread class, each of thread creates the unique object and associates with it while implementing the Runnable interface; multiple threads share the same object
	oThread class provides various inbuilt methods such as getPriority(), isAlive and many more while the Runnable interface provides a single method, i.e., run().
	
	12) What does join() method?
	The join() method waits for a thread to die. In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task. Join method is overloaded in Thread class in the following ways.
	opublic void join()throws InterruptedException
	opublic void join(long milliseconds)throws InterruptedException
	More details.
	
	13) Describe the purpose and working of sleep() method.
	The sleep() method in java is used to block a thread for a particular time, which means it pause the execution of a thread for a specific time. There are two methods of doing so.
	Syntax:
	opublic static void sleep(long milliseconds)throws InterruptedException
	opublic static void sleep(long milliseconds, int nanos)throws InterruptedException
	Working of sleep() method
	When we call the sleep() method, it pauses the execution of the current thread for the given time and gives priority to another thread(if available). Moreover, when the waiting time completed then again previous thread changes its state from waiting to runnable and comes in running state, and the whole process works so on till the execution doesn't complete.
	
	14) What is the difference between wait() and sleep() method?
	wait()	sleep()
	1) The wait() method is defined in Object class.	The sleep() method is defined in Thread class.
	2) The wait() method releases the lock.	The sleep() method doesn't release the lock.
	
	15) Is it possible to start a thread twice?
	No, we cannot restart the thread, as once a thread started and executed, it goes to the Dead state. Therefore, if we try to start a thread twice, it will give a runtimeException "java.lang.IllegalThreadStateException". Consider the following example.
	1.public class Multithread1 extends Thread  
	2.{  
	3.   public void run()  
	4.    {  
	5.      try {  
	6.          System.out.println("thread is executing now........");  
	7.      } catch(Exception e) {  
	8.      }   
	9.    }  
	10.    public static void main (String[] args) {  
	11.        Multithread1 m1= new Multithread1();  
	12.        m1.start();  
	13.        m1.start();  
	14.    }  
	15.}  
	Output
	thread is executing now........
	Exception in thread "main" java.lang.IllegalThreadStateException
		at java.lang.Thread.start(Thread.java:708)
		at Multithread1.main(Multithread1.java:13)
	More details.
	
	16) Can we call the run() method instead of start()?
	Yes, calling run() method directly is valid, but it will not work as a thread instead it will work as a normal object. There will not be context-switching between the threads. When we call the start() method, it internally calls the run() method, which creates a new stack for a thread while directly calling the run() will not create a new stack.
	More details.
	
	17) What about the daemon threads?
	The daemon threads are the low priority threads that provide the background support and services to the user threads. Daemon thread gets automatically terminated by the JVM if the program remains with the daemon thread only, and all other user threads are ended/died. There are two methods for daemon thread available in the Thread class:
	opublic void setDaemon(boolean status): It used to mark the thread daemon thread or a user thread.
	opublic boolean isDaemon(): It checks the thread is daemon or not.
	More details.
	
	18)Can we make the user thread as daemon thread if the thread is started?
	No, if you do so, it will throw IllegalThreadStateException. Therefore, we can only create a daemon thread before starting the thread.
	1.class Testdaemon1 extends Thread{    
	2.public void run(){  
	3.          System.out.println("Running thread is daemon...");  
	4.}  
	5.public static void main (String[] args) {  
	6.      Testdaemon1 td= new Testdaemon1();  
	7.      td.start();  
	8.      setDaemon(true);// It will throw the exception: td.   
	9.   }  
	10.}  
	Output
	Running thread is daemon...
	Exception in thread "main" java.lang.IllegalThreadStateException
	at java.lang.Thread.setDaemon(Thread.java:1359)
	at Testdaemon1.main(Testdaemon1.java:8)
	More details.
	
	19)What is shutdown hook?
	The shutdown hook is a thread that is invoked implicitly before JVM shuts down. So we can use it to perform clean up the resource or save the state when JVM shuts down normally or abruptly. We can add shutdown hook by using the following method:
	1.public void addShutdownHook(Thread hook){}    
	2.Runtime r=Runtime.getRuntime();  
	3.r.addShutdownHook(new MyThread());  
	Some important points about shutdown hooks are :
	oShutdown hooks initialized but can only be started when JVM shutdown occurred.
	oShutdown hooks are more reliable than the finalizer() because there are very fewer chances that shutdown hooks not run.
	oThe shutdown hook can be stopped by calling the halt(int) method of Runtime class.
	More details.
	
	20)When should we interrupt a thread?
	We should interrupt a thread when we want to break out the sleep or wait state of a thread. We can interrupt a thread by calling the interrupt() throwing the InterruptedException.
	More details.
	
	21) What is the synchronization?
	Synchronization is the capability to control the access of multiple threads to any shared resource. It is used:
	
	1.To prevent thread interference.
	2.To prevent consistency problem.
	When the multiple threads try to do the same task, there is a possibility of an erroneous result, hence to remove this issue, Java uses the process of synchronization which allows only one thread to be executed at a time. Synchronization can be achieved in three ways:
	oby the synchronized method
	oby synchronized block
	oby static synchronization
	Syntax for synchronized block
	1.synchronized(object reference expression)  
	2.    {  
	3.        //code block  
	4.    }  
	5.      
	More details.
	
	22) What is the purpose of the Synchronized block?
	The Synchronized block can be used to perform synchronization on any specific resource of the method. Only one thread at a time can execute on a particular resource, and all other threads which attempt to enter the synchronized block are blocked.
	oSynchronized block is used to lock an object for any shared resource.
	oThe scope of the synchronized block is limited to the block on which, it is applied. Its scope is smaller than a method.
	More details.
	
	23)Can Java object be locked down for exclusive use by a given thread?
	Yes. You can lock an object by putting it in a "synchronized" block. The locked object is inaccessible to any thread other than the one that explicitly claimed it.
	
	24) What is static synchronization?
	If you make any static method as synchronized, the lock will be on the class not on the object. If we use the synchronized keyword before a method so it will lock the object (one thread can access an object at a time) but if we use static synchronized so it will lock a class (one thread can access a class at a time). More details.
	
	25)What is the difference between notify() and notifyAll()?
	The notify() is used to unblock one waiting thread whereas notifyAll() method is used to unblock all the threads in waiting state.
	
	26)What is the deadlock?
	Deadlock is a situation in which every thread is waiting for a resource which is held by some other waiting thread. In this situation, Neither of the thread executes nor it gets the chance to be executed. Instead, there exists a universal waiting state among all the threads. Deadlock is a very complicated situation which can break our code at runtime.
	More details.
	
	27) How to detect a deadlock condition? How can it be avoided?
	We can detect the deadlock condition by running the code on cmd and collecting the Thread Dump, and if any deadlock is present in the code, then a message will appear on cmd.
	Ways to avoid the deadlock condition in Java:
	oAvoid Nested lock: Nested lock is the common reason for deadlock as deadlock occurs when we provide locks to various threads so we should give one lock to only one thread at some particular time.
	oAvoid unnecessary locks: we must avoid the locks which are not required.
	oUsing thread join: Thread join helps to wait for a thread until another thread doesn't finish its execution so we can avoid deadlock by maximum use of join method.
	
	28) What is Thread Scheduler in java?
	In Java, when we create the threads, they are supervised with the help of a Thread Scheduler, which is the part of JVM. Thread scheduler is only responsible for deciding which thread should be executed. Thread scheduler uses two mechanisms for scheduling the threads: Preemptive and Time Slicing.
	Java thread scheduler also works for deciding the following for a thread:
	oIt selects the priority of the thread.
	oIt determines the waiting time for a thread
	oIt checks the Nature of thread
	
	29) Does each thread have its stack in multithreaded programming?
	Yes, in multithreaded programming every thread maintains its own or separate stack area in memory due to which every thread is independent of each other.
	
	30) How is the safety of a thread achieved?
	If a method or class object can be used by multiple threads at a time without any race condition, then the class is thread-safe. Thread safety is used to make a program safe to use in multithreaded programming. It can be achieved by the following ways:
	oSynchronization
	oUsing Volatile keyword
	oUsing a lock based mechanism
	oUse of atomic wrapper classes
	
	31) What is race-condition?
	A Race condition is a problem which occurs in the multithreaded programming when various threads execute simultaneously accessing a shared resource at the same time. The proper use of synchronization can avoid the Race condition.
	
	32) What is the volatile keyword in java?
	Volatile keyword is used in multithreaded programming to achieve the thread safety, as a change in one volatile variable is visible to all other threads so one variable can be used by one thread at a time.
	
	33) What do you understand by thread pool?
	oJava Thread pool represents a group of worker threads, which are waiting for the task to be allocated.
	oThreads in the thread pool are supervised by the service provider which pulls one thread from the pool and assign a job to it.
	oAfter completion of the given task, thread again came to the thread pool.
	oThe size of the thread pool depends on the total number of threads kept at reserve for execution.
	The advantages of the thread pool are :
	oUsing a thread pool, performance can be enhanced.
	oUsing a thread pool, better system stability can occur.

SYNCRONISATION-
	Synchronization in Java
	Synchronization in java is the capability to control the access of multiple threads to any shared resource.
	Java Synchronization is better option where we want to allow only one thread to access the shared resource.
	
	Why use Synchronization
	The synchronization is mainly used to
	1.To prevent thread interference.
	2.To prevent consistency problem.
	
	Types of Synchronization
	There are two types of synchronization
	1.Process Synchronization
	2.Thread Synchronization
	Here, we will discuss only thread synchronization.
	
	Thread Synchronization
	There are two types of thread synchronization mutual exclusive and inter-thread communication.
	1.Mutual Exclusive
	1.Synchronized method.
	2.Synchronized block.
	3.static synchronization.
	2.Cooperation (Inter-thread communication in java)
	
	Mutual Exclusive
	Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java:
	1.by synchronized method
	2.by synchronized block
	3.by static synchronization
	
	Concept of Lock in Java
	Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object's fields has to acquire the object's lock before accessing them, and then release the lock when it's done with them.
	From Java 5 the package java.util.concurrent.locks contains several lock implementations.
	Java synchronized method
	If you declare any method as synchronized, it is known as synchronized method.
	Synchronized method is used to lock an object for any shared resource.
	When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task.
	Synchronized Block in Java
	Synchronized block can be used to perform synchronization on any specific resource of the method.
	Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block.
	If you put all the codes of the method in the synchronized block, it will work same as the synchronized method.
	Points to remember for Synchronized block
	oSynchronized block is used to lock an object for any shared resource.
	oScope of synchronized block is smaller than the method.
	Syntax to use synchronized block
	1.synchronized (object reference expression) {   
	2.  //code block   
	3.}  
	
	
	
	Static Synchronization
	If you make any static method as synchronized, the lock will be on the class not on object.
	
	Deadlock in java
	Deadlock in java is a part of multithreading. Deadlock can occur in a situation when a thread is waiting for an object lock, that is acquired by another thread and second thread is waiting for an object lock that is acquired by first thread. Since, both threads are waiting for each other to release the lock, the condition is called deadlock.
	
	
	next →← prev
	Inter-thread communication in Java
	Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other.
	Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.It is implemented by following methods of Object class:
	owait()
	onotify()
	onotifyAll()
	1) wait() method
	Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.
	2) notify() method
	Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. Syntax:
	public final void notify()
	
	3) notifyAll() method
	Wakes up all threads that are waiting on this object's monitor. Syntax:
	public final void notifyAll()
	
	The point to point explanation of the above diagram is as follows:
	1.Threads enter to acquire lock.
	2.Lock is acquired by on thread.
	3.Now thread goes to waiting state if you call wait() method on the object. Otherwise it releases the lock and exits.
	4.If you call notify() or notifyAll() method, thread moves to the notified state (runnable state).
	5.Now thread is available to acquire lock.
	6.After completion of the task, thread releases the lock and exits the monitor state of the object.
	
	Why wait(), notify() and notifyAll() methods are defined in Object class not Thread class?
	It is because they are related to lock and object has a lock.


EXCEPTION HANDLING-

	The Exception Handling in Java is one of the powerful mechanism to handle the runtime errors so that normal flow of the application can be maintained.
	In Java, an exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.
	Suppose there are 10 statements in your program and there occurs an exception at statement 5, the rest of the code will not be executed i.e. statement 6 to 10 will not be executed. If we perform exception handling, the rest of the statement will be executed. That is why we use exception handling in Java.
	Exception hierarchy-The topmost class is throwable class.(‘able’=interface for eg cloneable,serializable etc but throwable is a class)
                      
	Java Multi-catch block
	A try block can be followed by one or more catch blocks. Each catch block must contain a different exception handler. So, if you have to perform different tasks at the occurrence of different exceptions, use java multi-catch block.
	Points to remember
	At a time only one exception occurs and at a time only one catch block is executed.
	All catch blocks must be ordered from most specific to most general, i.e. catch for ArithmeticException must come before catch for Exception else will get a compiler error
	As of JAVA 7, if the code in the 2 catch blocks is same we can merge it using 'or' operator ie you can use multi-catch statement
	try{
	...
	}catch(StringIndexOutOfBound | NullPointerException e)
	{
		sysout("You have a string problem");
	}

	Java Nested try block
	The try block within a try block is known as nested try block in java.
	Why use nested try block
	Sometimes a situation may arise where a part of a block may cause one error and the entire block itself may cause another error. 
	In such cases, exception handlers have to be nested.
	1.try  
	2.{   statement 1;  
	3.    try  
	4.    {           statement 1;          } catch(Exception e) {}            
	5.}  
	6.catch(Exception e) {}  

	Why use java finally
	Finally block in java can be used to put "cleanup" code such as closing a file, closing connection etc.
	Rule: For each try block there can be zero or more catch blocks, but only one finally block.
	Note: The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).
	Finally block itself can have a try catch block (for eg to check if file is closed or db conn is closed or not)
	Combinations allowed:
	try-catch-finally
	try-catch
	try-finally

	Methods from the throwable obj
	e.getCausse()
	e.getMessage()
	e.getStackTrace()
	e.printStackTrace()


	Java Exception propagation
	An exception is first thrown from the top of the stack and if it is not caught, 
	it drops down the call stack to the previous method,
	If not caught there, the exception again drops down to the previous method, 
	and so on until they are caught or until they reach the very bottom of the call stack.
	This is called exception propagation.
	Rule: By default Unchecked Exceptions are forwarded in calling chain (propagated).
	Rule: By default, Checked Exceptions are not forwarded in calling chain (propagated)



	Any exception that is thrown out of a method must be specified as such by a throws clause.
	Even main can throw an exception because its LEGAL but as it is the frontdoor of our application, it's not really a good idea
	The "throws" keyword is used to declare exceptions. It doesn't throw an exception. It specifies that there may occur an exception in the method. 
	It is always used with method signature.
	Java throws keyword
	The Java throws keyword is used to declare an exception. It gives an information to the programmer that there may occur an exception 
	so it is better for the programmer to provide the exception handling code so that normal flow can be maintained.
	Exception Handling is mainly used to handle the checked exceptions. If there occurs any unchecked exception such as NullPointerException, 
	it is programmers fault that he is not performing check up before the code being used.
	Syntax of java throws
	1.return_type method_name() throws exception_class_name{  
	2.//method code  
	3.}  
	
	Which exception should be declared
	Ans) checked exception only, because:
	ounchecked Exception: under your control so correct your code.
	oerror: beyond your control e.g. you are unable to do anything if there occurs VirtualMachineError or StackOverflowError.
	
	Advantage of Java throws keyword
	Now Checked Exception can be propagated (forwarded in call stack).
	It provides information to the caller of the method about the exception.
	Rule: If you are calling a method that declares an exception, you must either caught or declare the exception.
	There are two cases:
	1.Case1:You caught the exception i.e. handle the exception using try/catch.
	2.Case2:You declare the exception i.e. specifying throws with the method.
	
	Case1: You handle the exception
	oIn case you handle the exception, the code will be executed fine whether exception occurs during the program or not.
	
	Case2: You declare the exception
	oA)In case you declare the exception, if exception does not occur, the code will be executed fine.
	oB)In case you declare the exception if exception occures, an exception will be thrown at runtime because throws does not handle the exception.
	o
	
	Difference between throw and throws in Java
	oThere are many differences between throw and throws keywords. A list of differences between throw and throws are given below:
	No.	Throw	throws
	1)	Java throw keyword is used to explicitly throw an exception.	Java throws keyword is used to declare an exception.
	2)	Checked exception cannot be propagated using throw only.	Checked exception can be propagated with throws.
	3)	Throw is followed by an instance.	Throws is followed by class.
	4)	Throw is used within the method.	Throws is used with the method signature.
	5)	You cannot throw multiple exceptions.	You can declare multiple exceptions e.g.
	public void method()throws IOException,SQLException.
	
	Que) Can we rethrow an exception?
	Yes, by throwing same exception in catch block.
	
	Difference between final, finally and finalize
	There are many differences between final, finally and finalize. A list of differences between final, finally and finalize are given below:
	No.	final	Finally	Finalize
	1)	Final is used to apply restrictions on class, method and variable. Final class can't be inherited, final method can't be overridden and final variable value can't be changed.	Finally is used to place important code, it will be executed whether exception is handled or not.	Finalize is used to perform clean up processing just before object is garbage collected.
	2)	Final is a keyword.	Finally is a block.	Finalize is a method.
	
	ExceptionHandling with MethodOverriding in Java
	There are many rules if we talk about methodoverriding with exception handling. 
	The Rules are as follows:
	*If the superclass method does not declare an exception*
	If the superclass method does not declare an exception, 
	subclass overridden method cannot declare the checked exception
	 but it can declare unchecked exception.
	*If the superclass method declares an exception*
	If the superclass method declares an exception, 
	subclass overridden method can declare same, subclass exception or 
	no exception but cannot declare parent exception.
	
	https://www.javatpoint.com/exception-handling-with-method-overriding  ( IMPORTANT!!! )
	https://www.javatpoint.com/custom-exception
	
	
	Difference between Checked and Unchecked Exceptions
	1) Checked Exception
	The classes which directly inherit Throwable class except RuntimeException and Error are known as checked exceptions e.g. IOException, SQLException etc. Checked exceptions are checked at compile-time.
	2) Unchecked Exception
	The classes which inherit RuntimeException are known as unchecked exceptions e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. Unchecked exceptions are not checked at compile-time, but they are checked at runtime.
	3) Error
	Error is irrecoverable e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc.

	CREATE YOUR OWN EXCEPTION:
	public class OverDraftException extends Exception{
		public OverDraftException(String message){  //constructor
				super(message);
		}
	}

	public void withdraw(double amount) throws OverDraftException{
	if(balance-amount < 0){
		throw new OverDraftException("insufficient funds");
	}
	}
	Which three statements are true about exception handling? (Choose three.)
	A. Only unchecked exceptions can be rethrown. //Both checked and unchecked exceptions can be rethrown in Java.
	B. All subclasses of the RuntimeException class are not recoverable. //B. RuntimeException and its subclasses are unchecked exceptions, but their recoverability depends on the specific situation and how the program is designed.
	C. The parameter in a catch block is of Throwable type. //true
	D. All subclasses of the RuntimeException class must be caught or declared to be thrown.//D. Subclasses of the RuntimeException class are unchecked exceptions. It is not mandatory to handle or declare RuntimeException and its subclasses.
	E. All subclasses of the RuntimeException class are unchecked exceptions. //true
	F. All subclasses of the Error class are not recoverable. //true

	Which two statements are true? (Choose two.)
	A. Error class is unextendable.
	B. Error class is extendable.
	C. Error is a RuntimeException.
	D. Error is an Exception.
	E. Error is a Throwable.


*>
What will be the result of compiling and executing Test class?
package com.udayan.oca;
public class Test {
     public static void main(String[] args) {
         m1(); //Line 3
     }
     private static void m1() throws Exception { //Line 6
         System.out.println("NOT THROWING ANY EXCEPTION"); //Line 7
     }
}
Explanation
If a method declares to throw Exception or its sub-type other than RuntimeException types, then calling method should follow handle or declare rule. 
In this case, as method m1() declares to throw Exception, 
so main method should either declare the same exception or its super type in its throws clause OR m1(); should be surrounded by try-catch block.
Hence line 3 gives compilation error

*>
package com.udayan.oca;
import java.io.FileNotFoundException;
import java.io.IOException;
 
abstract class Super {
     public abstract void m1() throws IOException;
}
 
class Sub extends Super {
     @Override
     public void m1() throws IOException {
         throw new FileNotFoundException();
     }
}
 
public class Test {
     public static void main(String[] args) {
         Super s = new Sub();
         try {
             s.m1();
         } catch (FileNotFoundException e) {
             System.out.print("M");
         } finally {
             System.out.print("N");
         }
     }
}
Explanation
Even though an instance of FileNotFoundException is thrown by method m1() at runtime, but method m1() declares to throw IOException.
Reference variable s is of Super type and hence for compiler, call to s.m1(); is to method m1() of Super, which throws IOException.
And as IOException is checked exception hence calling code should handle it.
As calling code doesn't handle IOException or its super type, so s.m1(); gives compilation error.


*>
public class Test {
     static {
         System.out.println(1/0);
     }
 
     public static void main(String[] args) {
         System.out.println("HELLO");
     }
}
On execution, does Test class print "HELLO" on to the console?
Explanation
To invoke the special main method, JVM loads the class in the memory. At that time, static initializer block is invoked. 
1/0 throws a RuntimeException and as a result static initializer block throws an instance of java.lang.ExceptionInInitializerError.

*>
Fill in the blanks for the definition of java.lang.Error class:

public class java.lang.Error extends ________________ {...}
Explanation 
An Error is a subclass of Throwable class.

package com.udayan.oca;
public class Test {
     public static void main(String[] args) {
         try {
             main(args);
         } catch (Exception ex) {
             System.out.println("CATCH-");
         }
             System.out.println("OUT");
     }
}
Explanation
main(args) method is invoked recursively without specifying any exit condition, so this code ultimately throws java.lang.StackOverflowError. StackOverflowError is a subclass of Error type and not Exception type, hence it is not handled. Stack trace is printed to the console and program ends abruptly.



INNER CLASS-
	
	Difference between nested class and inner class in Java
	There are two types of nested classes non-static and static nested classes.The non-static nested classes are also known as inner classes.
	https://www.javatpoint.com/java-inner-class#nesteddiff (IMPORTANT !!!) ENTIRE TOPIC.
	
	
	GENERICS-
		A generic type is a generic class or interface that is parameterized over types. 
	NON-GENERIC
	public class Box {
	    private Object object;
	
	    public void set(Object object) { this.object = object; }
	    public Object get() { return object; }
	z	}
	
	GENERIC
	public class Box<T> {
	    // T stands for "Type"
	    private T t;
	
	    public void set(T t) { this.t = t; }
	    public T get() { return t; }
	}
	
	
	We can also pass multiple Type parameters in Generic classes.
	
	class Test<T, U>
	
	Test <String, Integer> obj = 
	            new Test<String, Integer>("GfG", 15);
	
	Generic Functions:
	
	We can also write generic functions that can be called with different types of arguments based on the type of arguments passed to generic method, the compiler handles each method.
	Static and non-static generic methods are allowed, as well as generic class constructors.
	 For static generic methods, the type parameter section must appear before the method's return type.
	STATIC - public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2)
	
	NON STATIC- public <E> void method(E param)
	
	*What is type erasure?
	Generics is implemented using Type erasure, compiler erases all type related information during compile time and no type related information is available during runtime. for example List<String> is represented by only List at runtime.
	
	*What is Bounded and Unbounded wildcards in Generics ?
	
	Bounded Wildcards are those which impose bound on Type. there are two kinds of Bounded wildcards <? extends T> which impose an upper bound by ensuring that type must be sub class of T and <? super T> where its imposing lower bound by ensuring Type must be super class of T. This Generic Type must be instantiated with Type within bound otherwise it will result in compilation error. On the other hand <?> represent and unbounded type because <?> can be replace with any Type.
	
	NORMAL WAY-public static void printList(List<Object> list)
	UNBOUNDED-public static void printList(List<?> list)
	
	. How to write a generic method which accepts generic argument and return Generic Type?
	
	public V put(K key, V value) {
	        return cache.put(key, value);
	}
	
	
	Can we use generics with array?
	NO
	
	Q9. What Is a Wildcard Type?
	A wildcard type represents an unknown type. It's detonated with a question mark as follows:
	public static void consumeListOfWildcardType(List<?> list)
	Here, we are specifying a list which could be of any type. We could pass a list of anything into this method.
	Q10. What Is an Upper Bounded Wildcard?
	An upper bounded wildcard is when a wildcard type inherits from a concrete type. This is particularly useful when working with collections and inheritance.
	
	Q11. What Is an Unbounded Wildcard?
	An unbounded wildcard is a wildcard with no upper or lower bound, that can represent any type.
	What Is a Lower Bounded Wildcard?
	A lower bounded wildcard is when instead of providing an upper bound, we provide a lower bound by using the super keyword. In other words, a lower bounded wildcard means we are forcing the type to be a superclass of our bounded type. Let's try this with an example:
		public static void addDogs(List<? super Animal> list) {
		list.add(new Dog("tom"))
		}


SERIALIZATION AND DE-SERIALIZATION-
Serialization in Java is a mechanism of writing the state of an object into a byte-stream. It is mainly used in Hibernate, RMI, JPA, EJB and JMS technologies.
The reverse operation of serialization is called deserialization where byte-stream is converted into an object. The serialization and deserialization process is platform-independent, it means you can serialize an object in a platform and deserialize in different platform.
For serializing the object, we call the writeObject() method ObjectOutputStream, and for deserialization we call the readObject() method of ObjectInputStream class.
We must have to implement the Serializable interface for serializing the object.
Advantages of Java Serialization
It is mainly used to travel object's state on the network (which is known as marshaling).

java.io.Serializable interface
Serializable is a marker interface (has no data member and method). It is used to "mark" Java classes so that the objects of these classes may get a certain capability. The Cloneable and Remote are also marker interfaces.
It must be implemented by the class whose object you want to persist.
The String class and all the wrapper classes implement the java.io.Serializable interface by default.
Java Serialization with the static data member
If there is any static data member in a class, it will not be serialized because static is the part of class not object.
Java Serialization with array or collection
Rule: In case of array or collection, all the objects of array or collection must be serializable. If any object is not serialiizable, serialization will be failed.
Java Transient Keyword
Java transient keyword is used in serialization. If you define any data member as transient, it will not be serialized.
Let's take an example, I have declared a class as Student, it has three data members id, name and age. If you serialize the object, all the values will be serialized but I don't want to serialize one value, e.g. age then we can declare the age data member as transient.


1.import java.io.Serializable;  
2.public class Student implements Serializable{  
3. int id;  
4. String name;  
5. transient int age;//Now it will not be serialized  
6. public Student(int id, String name,int age) {  
7.  this.id = id;  
8.  this.name = name;  
9.  this.age=age;  
10. }  
11.}  

Now write the code to serialize the object.

1.import java.io.*;  
2.class PersistExample{  
3. public static void main(String args[])throws Exception{  
4.  Student s1 =new Student(211,"ravi",22);//creating object  
5.  //writing object into file  
6.  FileOutputStream f=new FileOutputStream("f.txt");  
7.  ObjectOutputStream out=new ObjectOutputStream(f);  
8.  out.writeObject(s1);  
9.  out.flush();  
10.  
11.  out.close();  
12.  f.close();  
13.  System.out.println("success");  
14. }  
15.} 

Output:
success

Now write the code for deserialization.

1.import java.io.*;  
2.class DePersist{  
3. public static void main(String args[])throws Exception{  
4.  ObjectInputStream in=new ObjectInputStream(new FileInputStream("f.txt"));  
5.  Student s=(Student)in.readObject();  
6.  System.out.println(s.id+" "+s.name+" "+s.age);  
7.  in.close();  
8. }  
9.}  
211 ravi 0
As you can see, printing age of the student returns 0 because value of age was not serialized.

	
GETTER/SETTER-
